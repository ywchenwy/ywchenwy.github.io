<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>script标签</title>
    <link href="/2023/10/26/script%E6%A0%87%E7%AD%BE/"/>
    <url>/2023/10/26/script%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="script-引入"><a href="#script-引入" class="headerlink" title="script 引入"></a>script 引入</h2><p><code>&lt;script&gt;</code> 引入 JS 的方式主要有三种：内联、外置，以及动态引入</p><p>动态引入：动态加载的脚本的情况，这种脚本默认为 async 加载形式，可通过将 async 属性设置为 false 来解除，让脚本顺序执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myScript = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>myScript.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;alert(&quot;hello world&quot;)&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(myScript)<br></code></pre></td></tr></table></figure><blockquote><p>通过 innerHTML 方式其实也能添加 script 标签，只是该标签下的 JS 不会运行，如</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="script-加载"><a href="#script-加载" class="headerlink" title="script 加载"></a>script 加载</h2><p>defer（延迟加载）和 async（异步加载）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 会立即加载并执行指定的脚本，js的下载和执行都会阻塞浏览器对HTML的解析</span><br>&lt;script src=<span class="hljs-string">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br><span class="hljs-comment">// 后续文档加载和js加载并行进行即异步，js执行会阻塞浏览器对HTML的解析</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="hljs-comment">// 后续文档加载和js加载并行进行即异步，js执行在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/../img/assets/scriptLoading.png" alt="script加载情况" title="script 脚步加载情况"></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a>type 属性</h3><p>type 属性原本是用来指定 script 脚本的 MIME 类型，默认值是 text&#x2F;javascript，其他值还有诸如：text&#x2F;ecmascript、application&#x2F;ecmascript、application&#x2F;javascript 等等，现代浏览器大多不理会这些值，而是把 type 用来支持 es6 的模块功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip type=<span class="hljs-string">&quot;module&quot;</span>&gt;&lt;/scrip&gt;<br></code></pre></td></tr></table></figure><blockquote><p>module 的默认加载机制就是 defer，如果和 async 属性一起使用，其加载方式就是 async</p></blockquote><p>除此之外，常常会看到 module script 下方还会跟一个 nomodule script：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip type=<span class="hljs-string">&quot;module&quot;</span> src=<span class="hljs-string">&quot;index.js&quot;</span>&gt;&lt;/scrip&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">scrip</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scrip</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这个功能主要是用来兼容一些老版本的浏览器：</p><p>支持 module 的浏览器，设定上就不会执行 nomodule 属性的 script 脚本，所以它只会跑上方的 js 脚本</p><p>而老版本的浏览器不支持 type&#x3D;”module”，会跳过这个 script 标签；同时又由于它不认识 nomodule 属性，反倒会执行 nomodule script 里的 js 文件</p><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><h3 id="integrity"><a href="#integrity" class="headerlink" title="integrity"></a>integrity</h3><p>该属性允许 script 标签提供一个 hash 值，用于检验加载的 JS 文件是否完整。比如，如下便签的 integrity 值就是告诉浏览器：使用 sha256 算法计算 JS 文件的摘要签名，然后对比 integrity 值，如果不一致就不执行该资源。它的主要功能就是防止托管在 CDN 上的资源被篡改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip<br>  src=<span class="hljs-string">&quot;//code.jquery.com/jquery.js&quot;</span><br>  integrity=<span class="hljs-string">&quot;sha256-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC&quot;</span><br>&gt;&lt;/scrip&gt;<br></code></pre></td></tr></table></figure><h3 id="nonce"><a href="#nonce" class="headerlink" title="nonce"></a>nonce</h3><p>nonce 是一个加密数字，需要配合 Content-Security-Policy 的 script-src 使用。举个例子，http 头的 CSP 属性如下：</p><p><code>Content-Security-Policy: script-src &#39;nonce-EfNBf03nceIOAn39fn389h3sdfa&#39;;</code></p><p>只有在 script 标签内带有相同 nonce 值的脚本才能执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script nonce=<span class="hljs-string">&quot;nonce-EfNBf03nceIOAn39fn389h3sdfa&quot;</span> src=<span class="hljs-string">&quot;./hello.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="referrerPolicy"><a href="#referrerPolicy" class="headerlink" title="referrerPolicy"></a>referrerPolicy</h3><p>该属性主要和 HTTP 头里的 Referer 配合使用。有些服务器审查比较严格，需要知道请求的“引荐人”（Referrer）；客户请求 API 时，需要同时发送引荐人信息。最简单的使用方式就是给相关的 script 标签添加 referrerPolicy 属性：<br><code>&lt;scrip referrerpolicy=&quot;origin&quot; src=&quot;./js/hello.js&quot;&gt;&lt;/scrip&gt;</code><br>如上代码中，hello.js 里的所有 api 请求都会在头信息里加上相应 URL 的域（origin）。referrerPolicy 的值很多，也很琐碎</p><blockquote><p>冷知识：HTTP 头的 Referer 有拼写错误，正确的写法是 Referrer；但是标准提案里写错了，结果大家就将错就错了</p></blockquote><h3 id="crossorigin"><a href="#crossorigin" class="headerlink" title="crossorigin"></a>crossorigin</h3><p>在 HTML5 中，<code>&lt;script&gt;</code> 与其他一些元素（<code>&lt;audio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>、和 <code>&lt;video&gt;</code>）提供了对 CORS 的支持； 他们均有一个跨域属性——crossorigin——来配置元素获取数据的 CORS 请求。一旦启用 crossorigin，http 头里须包含 Access-Control-Allow-Origin 属性，若该属性不存在或是源不必配，则不能加载资源。</p><p>Crossorigin 的默认值是 anonymous（空值或是无效值都等于 anonymous），表示对跨域请求不设置凭据标志；相反，想要提供该凭证，就需要设置 crossorigin&#x3D;”use-credentials”。（这里的凭据，指的就是 cookies、http 里的 auth，以及客户端的 SSL 证书）</p><h3 id="onload-onerror"><a href="#onload-onerror" class="headerlink" title="onload &amp; onerror"></a>onload &amp; onerror</h3><p>onload 和 onerror 算是两个隐藏属性吧，因为只能在<strong>动态引入</strong>时使用。顾名思义，onload 会指向成功加载时的事件，onerror 就是失败时触发的事件。用法也很简单，就是给这两个属性赋值某个事件函数。现实操作中常配合 crossorigin 使用，打印出三方源的一些错误信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.example.com/example.js&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br><br>script.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Success Loading&#x27;</span>)<br>&#125;<br><br>script.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Error Loading&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>扩展小知识：基本上所有包含 src 属性的 HTML 元素都有 onload 和 onerror 这两个隐藏属性，如： <code>&lt;img&gt;</code> 和 <code>&lt;iframe&gt;</code></p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>language: 早年间用来指定脚本语言的属性，如 Javascript、JavaScript1.2、VBScript，不过现在已弃用</p></li><li><p>charset：指定代码的字符集，如 charset&#x3D;”UTF-8”，可惜也已经过时了</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解CORS</title>
    <link href="/2023/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS/"/>
    <url>/2023/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h2><p>Cross-Origin Resource Sharing，跨域资源共享，是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他源，使得浏览器允许这些域加载自己的资源。</p><blockquote><p>跨域是不准确的，CORS 中，包括协议，域名，端口，只要其中之一不同，就是不同的源，因此也称跨源。</p></blockquote><ul><li>服务器：标识哪些源可以访问自己的资源</li><li>HTTP 头：Access-Control-Allow-Origin:* Origin: <a href="https://bilibili.com/">https://bilibili.com</a></li><li>浏览器：必须实现 CORS 相关的规范是否载入都有浏览器控制</li></ul><h2 id="CORS-的工作机制"><a href="#CORS-的工作机制" class="headerlink" title="CORS 的工作机制"></a>CORS 的工作机制</h2><p>script 标签载入了其他域的 JS 脚本，img 标签载入了其他域下的图片，不会作为 CORS 处理。</p><p>最常见适用 CORS 机制的是异步调用 Ajax，XMLHttpReques、Fetch API 等发起的跨域的 HTTP 请求，还有 Web 字体 (CSS 中通过 @font-face 使用跨源字体资源)，WebGL 贴图、使用 drawlmage() 将图片或视频画面绘制到 canvas</p><blockquote><p>简单请求，浏览器直接发起请求，适用于轻量服务，少了预检过程，提升响应速度；非简单请求，浏览器会先发起预检过程，适合于消耗资源的服务，可以减轻服务器压力</p></blockquote><h2 id="为什么需要-CORS"><a href="#为什么需要-CORS" class="headerlink" title="为什么需要 CORS"></a>为什么需要 CORS</h2><ol><li>保护服务器，这有助于减轻服务器的负载和风险</li><li>保护隐私，CORS 限制了敏感数据的访问</li><li>安全考虑，防止盗取用户数据或进行 CSRF 攻击</li><li>因为有实际的跨域请求需求，所以也不能完全禁止跨域请求</li></ol><h2 id="如何解决-CORS-问题"><a href="#如何解决-CORS-问题" class="headerlink" title="如何解决 CORS 问题"></a>如何解决 CORS 问题</h2><ol><li>同源策略（增加反向代理）, Nginx 或者 Apache</li><li>正确设置 CORS 标头，正确响应 Options 预检请求</li><li>JSONP</li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.bilibili.com/video/BV13z4y1F717/?spm_id_from=333.880.my_history.page.click&vd_source=c4a9c068747c74e67180a135f9b6799f">彻底搞懂 CORS（跨域资源共享）相关内容 什么是 CORS 为什么需要 CORS 如何解决 CORS 问题 简单请求 预检</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器插件之CORS Unblock</title>
    <link href="/2023/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E4%B9%8BCORS-Unblock/"/>
    <url>/2023/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E4%B9%8BCORS-Unblock/</url>
    
    <content type="html"><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul><li>跨域</li></ul><p>跨域全称为 Cross-Origin Resource Sharing，意为跨域资源共享，是一种允许当前域（domain）的资源被其他域（domain）的脚本请求访问的机制，通常由于同源安全策略，浏览器会禁止这种跨域请求。</p><p>而我们所说的跨域问题是因为违反了浏览器的同源安全策略而产生的。</p><ul><li>同源安全策略</li></ul><p>同源安全策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。</p><p>同源是指协议、域名、端口三者相同，即使两个不同的域名指向同一个 ip 地址也是非同源。</p><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</p><h2 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h2><ul><li><p>jsonp：json with padding</p></li><li><p>配置后端：CORS</p></li><li><p>中间服务器代理</p></li><li><p>正向代理<br>正向代理是代理服务器对客户端进行代理，为客户端收发请求，使得真实客户端对目标服务器不可见</p></li><li><p>反向代理<br>反向代理是代理服务器对目标服务器进行代理，为目标服务器进行收发请求，使得真实服务器对客户端不可见，如：Nginx</p></li></ul><p>此前我碰到一个需求，给我一个图片的链接，需要下载图片下来然后用 canvas 在其之上作画，会碰到这个问题:</p><blockquote><p>Uncaught DOMException: Failed to execute ‘toDataURL’ on ‘HTMLCanvasElement’: Tainted canvases may not be exported.</p></blockquote><p>这是受限于 CORS 策略，会存在跨域问题，虽然可以使用图像，但是绘制到画布上会污染画布，一旦一个画布被污染,就无法提取画布的数据，比如无法使用使用画布 toBlob(),toDataURL(),或 getImageData()方法；当使用这些方法的时候 会抛出上面的安全错误</p><p>网上的解决办法是给图片 img 加上一个属性：<code>image.setAttribute(&#39;crossorigin&#39;, &#39;anonymous&#39;);</code><br>并且后端开启 CORS 即可，但是由于受限，无法及时开启后端跨域，因此在高人指点下找到了一款插件 CORS Unblock，这个插件可以很好在自己的浏览器中解决跨域问题</p><p>另外经过查阅知道，火狐浏览器有一个插件叫 CORS Everywhere，谷歌浏览器、Edge 用 <a href="https://webextension.org/listing/access-control.html">CORS Unblock</a> 插件，当然这个插件的功能远不止如此。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>src 和 href 的区别</title>
    <link href="/2023/09/30/src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/30/src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><blockquote><p><code>src</code><strong>主要用于指定要加载的外部资源的路径</strong></p><p><code>href</code><strong>主要用于指定链接的目标资源的 URL</strong></p></blockquote><h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><ul><li>在<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>等标签中使用</li><li>用于指定外部资源的源 URL，浏览器需要获取并嵌入到当前文档中</li><li><code>src</code> 属性用于加载外部资源，如脚本、图片、视频、音频文件等</li></ul><h2 id="href"><a href="#href" class="headerlink" title="href"></a>href</h2><ul><li>在<code>&lt;a&gt;</code>、<code>&lt;link&gt;</code>和<code>&lt;area&gt;</code>等标签中使用</li><li>用于指定超链接的目标 URL，它可以是其他网页、CSS 文件、图片文件等</li><li><code>href</code> 属性用于定义超链接和资源的链接地址</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="请求资源类型不同"><a href="#请求资源类型不同" class="headerlink" title="请求资源类型不同"></a>请求资源类型不同</h3><ul><li><code>href</code>，超文本引用，用于建立文档与资源的联系，适用于：<code>&lt;link&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;base&gt;</code>等标签</li><li><code>src</code>，将其所指向的资源下载并应用到当前页面，适用于：<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>和<code>&lt;audio&gt;</code>等标签</li></ul><h3 id="作用结果不同"><a href="#作用结果不同" class="headerlink" title="作用结果不同"></a>作用结果不同</h3><ul><li><code>href</code>，用于文档与资源之间确立联系</li><li><code>src</code>，请求到的资源替换当前内容</li></ul><h3 id="浏览器解析不同"><a href="#浏览器解析不同" class="headerlink" title="浏览器解析不同"></a>浏览器解析不同</h3><ul><li><code>href</code>，将资源解析成 css 文件，并行加载请求资源，不会阻塞对当前文档的处理</li><li><code>src</code>，会暂停其他资源的处理，直到该资源加载、解析和执行完毕，将其所指向资源应用到当前內容。这也是为什么把 js 文件放在底部而不是放在头部的原因</li></ul><h3 id="语义不同"><a href="#语义不同" class="headerlink" title="语义不同"></a>语义不同</h3><ul><li><code>src</code>属性在页面渲染过程中会阻塞后续内容的加载，因为浏览器会优先加载并执行<code>src</code>对应的资源</li><li><code>href</code>属性不会阻塞后续内容的加载，因此适用于需要异步加载的资源，如样式表和字体文件等</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
