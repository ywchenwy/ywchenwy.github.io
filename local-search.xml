<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>eslint 和 prettier 的冲突配置</title>
    <link href="/2025/05/17/eslint-%E5%92%8C-prettier-%E7%9A%84%E5%86%B2%E7%AA%81%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/05/17/eslint-%E5%92%8C-prettier-%E7%9A%84%E5%86%B2%E7%AA%81%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://eslint.org/">ESLint</a> 和 <a href="https://prettier.io/">Prettier</a> 是前端开发两种常用的工具，用于提升代码质量和一致性。ESLint 是一个代码质量检查工具，通过静态分析发现潜在的错误和不符合规范的代码；Prettier 是一个代码格式化工具，强制执行一致的代码风格。然而，由于两者都会涉及代码格式化规则，配置不当可能导致冲突，例如保存文件时代码格式反复切换（如单引号与双引号互换）。本文将深入探讨在 ESLint 9（采用平坦配置）和 ESLint 8（传统配置）中如何正确配置 ESLint 和 Prettier，以避免冲突并实现无缝协作。</p><h2 id="ESLint-和-Prettier-的功能与冲突原因"><a href="#ESLint-和-Prettier-的功能与冲突原因" class="headerlink" title="ESLint 和 Prettier 的功能与冲突原因"></a>ESLint 和 Prettier 的功能与冲突原因</h2><h3 id="ESLint-的功能"><a href="#ESLint-的功能" class="headerlink" title="ESLint 的功能"></a>ESLint 的功能</h3><p>ESLint 通过定义规则检查代码，涵盖代码质量（如未使用的变量）和格式化（如缩进、引号样式）。它支持自动修复（<code>--fix</code>）部分问题，但其格式化规则可能与 Prettier 的输出冲突。</p><h3 id="Prettier-的功能"><a href="#Prettier-的功能" class="headerlink" title="Prettier 的功能"></a>Prettier 的功能</h3><p>Prettier 是一个高度自动化的代码格式化工具，解析代码并按照其内置规则重新格式化，强调一致性。它支持 JavaScript、TypeScript、CSS 等多种语言，配置选项较少，注重“零配置”体验。</p><h3 id="冲突原因"><a href="#冲突原因" class="headerlink" title="冲突原因"></a>冲突原因</h3><p>冲突主要源于两者在格式化规则上的重叠。例如：</p><ul><li>ESLint 的 <code>quotes</code> 规则可能要求使用双引号，而 Prettier 的默认设置可能是单引号。</li><li>ESLint 的 <code>indent</code> 规则可能要求 2 个空格缩进，而 Prettier 可能根据 <code>.prettierrc</code> 配置使用 4 个空格。</li><li>当两者同时运行自动修复（例如通过 VS Code 的“保存时格式化”），它们可能反复覆盖彼此的更改，导致格式不稳定。</li></ul><p>为解决这些问题，推荐使用 <code>eslint-config-prettier</code> 禁用 ESLint 中与 Prettier 冲突的格式化规则，并使用 <code>eslint-plugin-prettier</code> 将 Prettier 集成到 ESLint 工作流中，确保格式化由 Prettier 主导。</p><h2 id="ESLint-9-配置（平坦配置）"><a href="#ESLint-9-配置（平坦配置）" class="headerlink" title="ESLint 9 配置（平坦配置）"></a>ESLint 9 配置（平坦配置）</h2><p>ESLint 9 引入了<a href="https://eslint.org/docs/latest/use/configure/configuration-files">平坦配置</a>（<code>eslint.config.js</code>），取代了传统的 <code>.eslintrc</code> 文件。以下是在 ESLint 9 中 ESLint 和 Prettier 冲突的配置示例。</p><h3 id="配置-ESLint"><a href="#配置-ESLint" class="headerlink" title="配置 ESLint"></a>配置 ESLint</h3><p><code>eslint.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> eslintConfigPrettier <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;eslint-config-prettier&quot;</span>; <span class="hljs-comment">// 禁用与 Prettier 冲突的 ESLint 格式化规则</span><br><span class="hljs-keyword">import</span> eslintPluginPrettier <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;eslint-plugin-prettier&quot;</span>; <span class="hljs-comment">// 将 Prettier 集成到 ESLint，违反 Prettier 规则时会报错</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [<br>  &#123;<br>    <span class="hljs-attr">files</span>: [<span class="hljs-string">&quot;**/*.&#123;js,jsx,ts,tsx&#125;&quot;</span>],<br>    <span class="hljs-attr">languageOptions</span>: &#123;<br>      <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-string">&quot;latest&quot;</span>,<br>      <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: &#123;<br>      <span class="hljs-attr">prettier</span>: eslintPluginPrettier,<br>    &#125;,<br>    <span class="hljs-attr">rules</span>: &#123;<br>      ...eslintConfigPrettier.<span class="hljs-property">rules</span>,<br>      <span class="hljs-comment">// 自定义规则...</span><br>    &#125;,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> eslintPluginPrettierRecommended <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;eslint-plugin-prettier/recommended&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [<br>  &#123;<br>    <span class="hljs-attr">files</span>: [<span class="hljs-string">&quot;**/*.&#123;js,jsx,ts,tsx&#125;&quot;</span>],<br>    <span class="hljs-attr">languageOptions</span>: &#123;<br>      <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-string">&quot;latest&quot;</span>,<br>      <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>    &#125;,<br>    <span class="hljs-attr">rules</span>: &#123;<br>      <span class="hljs-comment">// 自定义代码质量规则</span><br>      <span class="hljs-string">&quot;no-unused-vars&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-comment">// 放在最后以覆盖其他配置的格式化规则</span><br>  eslintPluginPrettierRecommended,<br>];<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><code>eslint-plugin-prettier/recommended</code> 自动启用 <code>eslint-plugin-prettier</code> 和 <code>eslint-config-prettier</code>，并将 <code>prettier/prettier</code> 规则设置为 <code>error</code>，确保 Prettier 的格式化规则通过 ESLint 强制执行。</li><li><code>eslint-config-prettier</code> 禁用了所有可能与 Prettier 冲突的 ESLint 格式化规则（如 <code>indent</code>、<code>quotes</code>）。</li><li>将 <code>eslintPluginPrettierRecommended</code> 放在配置数组的最后，确保它能覆盖其他配置中的格式化规则。</li></ul><h2 id="ESLint-8-配置（传统配置）"><a href="#ESLint-8-配置（传统配置）" class="headerlink" title="ESLint 8 配置（传统配置）"></a>ESLint 8 配置（传统配置）</h2><p>ESLint 8 使用传统的 <code>.eslintrc</code> 配置文件（支持 JSON、JavaScript 或 YAML 格式）。以下是配置步骤。</p><h3 id="配置-ESLint-1"><a href="#配置-ESLint-1" class="headerlink" title="配置 ESLint"></a>配置 ESLint</h3><p><code>.eslintrc.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">extends</span>: [<br>    <span class="hljs-string">&quot;eslint:recommended&quot;</span>,<br>    <span class="hljs-string">&quot;plugin:prettier/recommended&quot;</span>, <span class="hljs-comment">// 启用 eslint-plugin-prettier 和 eslint-config-prettier</span><br>  ],<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&quot;prettier&quot;</span>],<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-string">&quot;prettier/prettier&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-comment">// 启用 prettier 规则</span><br>  &#125;,<br>  <span class="hljs-attr">parserOptions</span>: &#123;<br>    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>    <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-string">&quot;latest&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>或者<br><code>.eslintrc.json</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;browser&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;es2021&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;extends&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;eslint:recommended&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;plugin:prettier/recommended&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;parserOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ecmaVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">12</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;sourceType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;module&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;prettier&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;no-unused-vars&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;error&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;prettier/prettier&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;error&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li><code>plugin:prettier/recommended</code> 扩展了 <code>eslint-plugin-prettier</code> 和 <code>eslint-config-prettier</code>，并启用 <code>prettier/prettier</code> 规则。</li><li>将 <code>&quot;prettier&quot;</code> 放在 <code>extends</code> 数组的最后，确保它覆盖其他配置中的格式化规则。</li><li>明确添加 <code>&quot;plugins&quot;: [&quot;prettier&quot;]</code> 以启用 Prettier 插件。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p><strong>VS Code 配置</strong>：在 VS Code 中，确保安装 ESLint 和 Prettier 扩展，并配置保存时自动修复：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// vscode-eslint</span><br>  <span class="hljs-attr">&quot;editor.formatOnType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;eslint.codeAction.showDocumentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;enable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;editor.codeActionsOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;source.fixAll.eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;explicit&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;eslint.validate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;javascript&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;javascriptreact&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;typescript&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;typescriptreact&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-comment">// prettier-vscode</span><br>  <span class="hljs-attr">&quot;[javascript]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esbenp.prettier-vscode&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;[javascriptreact]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esbenp.prettier-vscode&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;[typescript]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esbenp.prettier-vscode&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;[typescriptreact]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esbenp.prettier-vscode&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;[html]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esbenp.prettier-vscode&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>确保 Prettier 不是默认格式化程序，以避免重复格式化。</p></li><li><p><strong>运行顺序</strong>：始终让 Prettier 负责格式化，ESLint 负责代码质量检查。避免单独运行 <code>prettier --write</code> 和 <code>eslint --fix</code>，推荐通过 ESLint 的 <code>--fix</code> 执行所有修复。</p></li><li><p><strong>检查冲突</strong>：使用 <code>npx eslint-config-prettier &lt;file&gt;</code> 检查 ESLint 配置中是否仍有与 Prettier 冲突的规则。如果发现冲突，手动移除或调整相关规则。</p></li><li><p><strong>ESLint 9 的平坦配置</strong>：平坦配置更模块化，但需要注意配置顺序。确保 <code>eslint-plugin-prettier/recommended</code> 在数组最后以覆盖其他规则。</p></li><li><p><strong>社区资源</strong>：参考 <a href="https://github.com/prettier/eslint-config-prettier">eslint-config-prettier</a> 和 <a href="https://github.com/prettier/eslint-plugin-prettier">eslint-plugin-prettier</a> 的官方文档，获取最新配置建议。</p></li><li><p><strong>TypeScript 项目</strong>：对于 TypeScript 项目，可能需要额外安装 <code>@typescript-eslint/parser</code> 和 <code>@typescript-eslint/eslint-plugin</code>，并在配置中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ESLint 9</span><br>&#123;<br>  <span class="hljs-attr">files</span>: [<span class="hljs-string">&#x27;**/*.ts&#x27;</span>],<br>  <span class="hljs-attr">languageOptions</span>: &#123;<br>    <span class="hljs-attr">parser</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@typescript-eslint/parser&#x27;</span>),<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-string">&#x27;@typescript-eslint&#x27;</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@typescript-eslint/eslint-plugin&#x27;</span>),<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过正确配置 <code>eslint-config-prettier</code> 和 <code>eslint-plugin-prettier</code>，可以在 ESLint 9 和 ESLint 8 中有效避免 ESLint 和 Prettier 的冲突。ESLint 9 的平坦配置提供了更现代化的模块化方式，而 ESLint 8 的传统配置则更适合现有项目。关键是禁用 ESLint 的格式化规则，让 Prettier 统一处理代码格式化，同时保留 ESLint 的代码质量检查能力。</p><p>在项目中，建议将这些配置集成到 CI&#x2F;CD 流程中，确保团队成员的代码风格一致。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eslint</tag>
      
      <tag>prettier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postcss-px-to-viewport 实现响应式布局</title>
    <link href="/2025/05/17/postcss-px-to-viewport-%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2025/05/17/postcss-px-to-viewport-%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>响应式设计是适配多种设备屏幕尺寸的关键。传统的像素（px）单位在不同设备上无法动态缩放，需要手动调整样式以适配移动端和桌面端。<code>postcss-px-to-viewport</code>是一个 PostCSS 插件，它们能将 CSS 中的 px 单位自动转换为视口单位（如 vw、vh、vmin、vmax），从而简化响应式布局开发流程。</p><h2 id="什么是-PostCSS-和视口单位"><a href="#什么是-PostCSS-和视口单位" class="headerlink" title="什么是 PostCSS 和视口单位"></a>什么是 PostCSS 和视口单位</h2><p><a href="https://postcss.org/">PostCSS</a> 是一个基于 JavaScript 的 CSS 处理工具，通过插件机制支持 CSS 转换、自动添加前缀、语法检查等功能。它被广泛应用于现代前端开发，兼容 Webpack、Vite 等构建工具。</p><p>视口单位（如 vw、vh）是相对于浏览器视口尺寸的相对单位：</p><ul><li><strong>1vw</strong>：等于视口宽度的 1&#x2F;100。</li><li><strong>1vh</strong>：等于视口高度的 1&#x2F;100。</li><li><strong>vmin&#x2F;vmax</strong>：分别取视口宽高中的较小值或较大值的 1&#x2F;100。</li></ul><h2 id="插件简介"><a href="#插件简介" class="headerlink" title="插件简介"></a>插件简介</h2><h3 id="postcss-px-to-viewport"><a href="#postcss-px-to-viewport" class="headerlink" title="postcss-px-to-viewport"></a>postcss-px-to-viewport</h3><p><code>postcss-px-to-viewport</code> 是一个流行的 PostCSS 插件，旨在将 CSS 中的 px 单位转换为视口单位。它特别适合需要基于单一设计尺寸（如移动端 375px 宽的设计稿）创建可扩展界面的项目。该插件由 Evrone 开发，支持多种视口单位（vw、vh、vmin、vmax），并提供丰富的配置选项以控制转换行为。<a href="https://github.com/evrone/postcss-px-to-viewport">postcss-px-to-viewport</a></p><p><strong>特点</strong>：</p><ul><li>支持忽略特定选择器或属性。</li><li>可配置媒体查询中的单位转换。</li><li>支持横屏模式下的视口单位转换。</li><li>提供特殊注释（如 <code>/* px-to-viewport-ignore */</code>）以跳过特定行的转换。</li></ul><h3 id="postcss-px-to-viewport-8-plugin"><a href="#postcss-px-to-viewport-8-plugin" class="headerlink" title="postcss-px-to-viewport-8-plugin"></a>postcss-px-to-viewport-8-plugin</h3><p><code>postcss-px-to-viewport-8-plugin</code> 是基于 <code>postcss-px-to-viewport</code> 的一个分支，专为 PostCSS 8 及以上版本优化。由于 PostCSS 8 重构了 API，旧版本插件可能不兼容新版本构建工具，因此该插件应运而生。它保留了原插件的核心功能，同时适配了现代前端生态。<a href="https://www.npmjs.com/package/postcss-px-to-viewport-8-plugin">postcss-px-to-viewport-8-plugin</a></p><p><strong>特点</strong>：</p><ul><li>与 PostCSS 8+ 完全兼容。</li><li>支持动态视口宽度配置（例如根据文件名区分移动端和桌面端）。</li><li>提供更灵活的属性过滤和忽略规则。</li><li>适用于 Vite、Webpack 等现代构建工具。</li></ul><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><h3 id="postcss-px-to-viewport-配置"><a href="#postcss-px-to-viewport-配置" class="headerlink" title="postcss-px-to-viewport 配置"></a>postcss-px-to-viewport 配置</h3><p>插件配置示例如下（个人项目使用到了 <code>react-vant</code> 组件库，并分开配置）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;<br><span class="hljs-keyword">import</span> postcssPxToViewport <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;postcss-px-to-viewport-8-plugin&quot;</span>; <span class="hljs-comment">// 将 px 单位转为 vw，适配移动端</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-comment">// PostCSS 配置（用于 autoprefixer 和 pxtorem）</span><br>    <span class="hljs-attr">postcss</span>: &#123;<br>      <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-title function_">autoprefixer</span>(), <span class="hljs-comment">// 自动添加浏览器前缀</span><br>        <span class="hljs-title function_">postcssPxToViewport</span>(&#123;<br>          <span class="hljs-attr">unitToConvert</span>: <span class="hljs-string">&quot;px&quot;</span>, <span class="hljs-comment">// 需要转换的单位，默认为&quot;px&quot;</span><br>          <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">375</span>, <span class="hljs-comment">// 设计稿的视口宽度</span><br>          <span class="hljs-attr">unitPrecision</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// 单位转换后保留的精度</span><br>          <span class="hljs-attr">propList</span>: [<span class="hljs-string">&quot;*&quot;</span>], <span class="hljs-comment">// 能转化为vw的属性列表</span><br>          <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&quot;vmin&quot;</span>, <span class="hljs-comment">// 希望使用的视口单位</span><br>          <span class="hljs-attr">fontViewportUnit</span>: <span class="hljs-string">&quot;vmin&quot;</span>, <span class="hljs-comment">// 字体使用的视口单位</span><br>          <span class="hljs-attr">selectorBlackList</span>: [], <span class="hljs-comment">// 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。</span><br>          <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 设置最小的转换数值，只有大于1的值会被转换</span><br>          <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 媒体查询里的单位是否需要转换单位</span><br>          <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//  是否直接更换属性值，而不添加备用属性</span><br>          <span class="hljs-attr">exclude</span>: [<span class="hljs-regexp">/node_modules/</span>], <span class="hljs-comment">// 忽略某些文件夹下的文件或特定文件</span><br>          <span class="hljs-attr">include</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 如果设置了include，那将只有匹配到的文件才会被转换</span><br>          <span class="hljs-attr">landscape</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape)</span><br>          <span class="hljs-attr">landscapeUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 横屏时使用的单位</span><br>          <span class="hljs-attr">landscapeWidth</span>: <span class="hljs-number">667</span>, <span class="hljs-comment">// 横屏aa时使用的视口宽度</span><br>        &#125;),<br>        <span class="hljs-title function_">postcssPxToViewport</span>(&#123;<br>          <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">375</span>,<br>          <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&quot;vmin&quot;</span>,<br>          <span class="hljs-attr">fontViewportUnit</span>: <span class="hljs-string">&quot;vmin&quot;</span>,<br>          <span class="hljs-attr">exclude</span>: <span class="hljs-literal">undefined</span>,<br>          <span class="hljs-attr">include</span>: [<span class="hljs-regexp">/node_modules\/react-vant/i</span>],<br>          <span class="hljs-attr">landscapeWidth</span>: <span class="hljs-number">667</span>,<br>        &#125;),<br>      ],<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><strong>浏览器兼容性</strong>：视口单位在现代浏览器中支持良好，但在旧版 IE 和 Android 浏览器中可能需要额外的 polyfill 或回退方案。</li><li><strong>设计稿一致性</strong>：确保开发团队使用的设计稿宽度与插件配置的 <code>viewportWidth</code> 一致，避免比例计算错误。</li><li><strong>性能影响</strong>：在大型项目中，转换大量 CSS 规则可能略微增加构建时间，建议通过 <code>exclude</code> 忽略不必要的文件。</li><li><strong>调试技巧</strong>：使用 <code>/* px-to-viewport-ignore */</code> 或 <code>selectorBlackList</code> 精确控制转换范围，方便调试复杂样式。</li><li><strong>PostCSS 版本</strong>：如果使用 PostCSS 8 及以上，优先选择 <code>postcss-px-to-viewport-8-plugin</code> 以确保兼容性。</li><li><strong>include 功能未实现</strong>：虽然文档中提到 <code>include</code> 选项可以指定只转换特定文件（例如只处理 <code>src/mobile/</code> 下的文件），但根据 GitHub 页面和相关讨论，<code>postcss-px-to-viewport</code> 和 <code>postcss-px-to-viewport-8-plugin</code> 的 <code>include</code> 功能并未完全实现。个人可能需要依赖 <code>exclude</code> 配置或通过文件分离等其他工作流来实现类似效果。此外，这两个插件的社区已停止维护和更新。因此，本人选择下载源码，自行实现 <code>include</code> 功能，并将其部署到私有仓库中，作为替换插件使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>postcss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>换行回车</title>
    <link href="/2024/11/11/%E6%8D%A2%E8%A1%8C%E5%9B%9E%E8%BD%A6/"/>
    <url>/2024/11/11/%E6%8D%A2%E8%A1%8C%E5%9B%9E%E8%BD%A6/</url>
    
    <content type="html"><![CDATA[<p>在编写跨平台文本文件、处理流数据或日志文件时，<code> \r</code>、<code>\n</code> 和 <code>\r\n</code> 是我们常遇到的行尾符。</p><h3 id="1-行尾符的起源"><a href="#1-行尾符的起源" class="headerlink" title="1. 行尾符的起源"></a>1. 行尾符的起源</h3><p>行尾符的设计可以追溯到机械打字机时代。当时，行尾是分为两个步骤的：</p><ul><li><strong>回车（Carriage Return）</strong>：将打字头移动到当前行的行首。</li><li><strong>换行（Line Feed）</strong>：将打字纸向上滚动一行，准备书写新行的内容。</li></ul><p>早期的计算机系统借鉴了这种机制，分别使用<strong>回车符 <code>\r</code></strong> 和<strong>换行符 <code>\n</code></strong> ，但不同操作系统有各自的行尾符表示方式，导致了如今的差异。</p><hr><h3 id="2-n、-r-和-r-n-的含义"><a href="#2-n、-r-和-r-n-的含义" class="headerlink" title="2. \n、\r 和 \r\n 的含义"></a>2. <code>\n</code>、<code>\r</code> 和 <code>\r\n</code> 的含义</h3><ul><li><strong><code>\n</code> (Line Feed, LF)</strong> ：用于换行，将光标移动到下一行的行首。</li><li><strong><code>\r</code> (Carriage Return, CR)</strong> ：用于回车，将光标移到当前行的行首。</li><li><strong><code>\r\n</code> (CR+LF)</strong> ：在某些系统中表示完整的“回车+换行”操作，即将光标移动到下一行的行首。</li></ul><hr><h3 id="3-不同系统中的行尾符"><a href="#3-不同系统中的行尾符" class="headerlink" title="3. 不同系统中的行尾符"></a>3. 不同系统中的行尾符</h3><p>不同操作系统对行尾符的处理方式有所不同：</p><ul><li><strong>Unix&#x2F;Linux 系统</strong>：使用 <code>\n</code> 表示行尾符。这种方式最简洁且高效，也被现代 macOS 系统所采用。</li><li><strong>Windows 系统</strong>：使用 <code>\r\n</code> 表示行尾符，主要是为了保持对 DOS 系统的兼容性。</li><li><strong>旧式 Mac OS 系统</strong>：在 macOS 9 及之前的版本中使用 <code>\r</code> 作为行尾符。现代 macOS 采用了 Unix 标准的 <code>\n</code>。</li></ul><p>由于这些差异，在不同系统之间传输文本文件时，行尾符的转换可能会带来困扰，导致文本解析错误或多余空行。</p><hr><h3 id="4-跨平台文件处理中的行尾符兼容性问题"><a href="#4-跨平台文件处理中的行尾符兼容性问题" class="headerlink" title="4. 跨平台文件处理中的行尾符兼容性问题"></a>4. 跨平台文件处理中的行尾符兼容性问题</h3><p>在编写跨平台代码时，行尾符的不兼容常常引发意想不到的错误。例如：</p><ul><li><strong>读取 Windows 文件</strong>：如果在 Unix 系统中读取 Windows 格式的文本文件，<code>\r\n</code> 中的 <code>\r</code> 可能被视为多余字符，导致不符合预期的文件格式。</li><li><strong>写入跨平台文件</strong>：在处理配置文件或代码文件时，不同的行尾符可能影响文件的解析和执行。</li></ul><p>为解决这些问题，通常在文件处理时，需将行尾符统一为 <code>\n</code>，以适应 Unix 和现代 macOS 的格式。</p><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>理解 <code>\r</code>、<code>\n</code> 和 <code>\r\n</code> 的区别有助于在处理文本文件、流数据、跨平台日志记录时避免不必要的麻烦：</p><ul><li><strong>Unix&#x2F;Linux 和 macOS 系统</strong>：使用 <code>\n</code>。</li><li><strong>Windows 系统</strong>：使用 <code>\r\n</code>。</li><li><strong>旧式 Mac OS</strong>：使用 <code>\r</code>（在现代 macOS 中已被弃用）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LF</tag>
      
      <tag>CR</tag>
      
      <tag>CRLF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XMLHttpRequest、Fetch、Axios与AJAX</title>
    <link href="/2024/11/10/XMLHttpRequest%E3%80%81Fetch%E3%80%81Axios%E4%B8%8EAJAX/"/>
    <url>/2024/11/10/XMLHttpRequest%E3%80%81Fetch%E3%80%81Axios%E4%B8%8EAJAX/</url>
    
    <content type="html"><![CDATA[<h3 id="基于-HTTP-协议的前后端通信工具"><a href="#基于-HTTP-协议的前后端通信工具" class="headerlink" title="基于 HTTP 协议的前后端通信工具"></a>基于 HTTP 协议的前后端通信工具</h3><h4 id="XMLHttpRequest（原生-JavaScript-对象）"><a href="#XMLHttpRequest（原生-JavaScript-对象）" class="headerlink" title="XMLHttpRequest（原生 JavaScript 对象）"></a>XMLHttpRequest（原生 JavaScript 对象）</h4><p><strong>XMLHttpRequest (XHR)</strong> 是一个原生 JavaScript 对象，允许在不刷新页面的情况下请求特定 URL 并获取数据。</p><p><strong>特性</strong>：</p><ul><li>浏览器广泛支持</li><li>功能丰富：支持跟踪请求的状态、进度事件、文件上传、同步请求等</li><li>支持同步和异步请求</li><li>不支持 Promise API</li></ul><hr><h4 id="Fetch（浏览器原生-API）"><a href="#Fetch（浏览器原生-API）" class="headerlink" title="Fetch（浏览器原生 API）"></a>Fetch（浏览器原生 API）</h4><p><strong>Fetch API</strong> 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 请求与响应。Fetch API 引入了全局 <code>fetch()</code> 方法，以简单、合理的方式异步获取网络资源，是 XMLHttpRequest 的理想替代方案。</p><p><strong>特点</strong>：</p><ul><li><code>fetch()</code> 方法用于发起资源请求，返回一个表示请求响应的 Promise</li><li>相比 XMLHttpRequest，语法更简洁</li><li>支持 Promise API</li><li>支持流式处理，允许逐步读取响应数据，适合大文件处理</li></ul><hr><h4 id="Axios（第三方库）"><a href="#Axios（第三方库）" class="headerlink" title="Axios（第三方库）"></a>Axios（第三方库）</h4><p><strong>Axios</strong> 是一个基于 Promise 的网络请求库，兼容浏览器和 Node.js。Axios 的同构性允许同一套代码运行在浏览器和 Node.js 环境中。在服务器端，Axios 使用原生的 Node.js <code>http</code> 模块；在客户端使用 XMLHttpRequest。</p><p><strong>其他特性</strong>：</p><ul><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>超时处理</li><li>查询参数序列化，支持嵌套项处理</li><li>自动将请求体序列化为 JSON、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code></li><li>自动解析 JSON 数据</li><li>支持获取请求进度信息（速度、剩余时间等）</li><li>客户端支持防御 XSRF</li></ul><hr><h4 id="Axios、Fetch-和-XMLHttpRequest-比较"><a href="#Axios、Fetch-和-XMLHttpRequest-比较" class="headerlink" title="Axios、Fetch 和 XMLHttpRequest 比较"></a>Axios、Fetch 和 XMLHttpRequest 比较</h4><table><thead><tr><th align="center">特性</th><th align="center">XMLHttpRequest</th><th align="center">Fetch</th><th align="center">Axios</th></tr></thead><tbody><tr><td align="center">Promise 支持</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">语法简洁</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">自动 JSON 解析</td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">错误处理</td><td align="center">需要手动处理</td><td align="center">需要手动检查状态码</td><td align="center">自动处理 HTTP 错误</td></tr><tr><td align="center">进度跟踪</td><td align="center">是</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">拦截器</td><td align="center">否</td><td align="center">否</td><td align="center">请求和响应拦截器</td></tr><tr><td align="center">请求取消</td><td align="center">需要手动实现</td><td align="center">使用 AbortController</td><td align="center">支持 AbortController</td></tr><tr><td align="center">浏览器兼容性</td><td align="center">所有浏览器</td><td align="center">现代浏览器（需 polyfill）</td><td align="center">现代浏览器（需引入库）</td></tr><tr><td align="center">Node.js 支持</td><td align="center">否</td><td align="center">需 polyfill</td><td align="center">是</td></tr><tr><td align="center">体积</td><td align="center">原生 JS 对象</td><td align="center">原生 API</td><td align="center">外部库，体积较大</td></tr><tr><td align="center">流式处理响应</td><td align="center">否</td><td align="center">是（支持 ReadableStream）</td><td align="center">否</td></tr><tr><td align="center">同步请求</td><td align="center">支持</td><td align="center">不支持</td><td align="center">不支持</td></tr></tbody></table><hr><h4 id="Axios-为什么使用-XMLHttpRequest-而不是更现代的-Fetch？"><a href="#Axios-为什么使用-XMLHttpRequest-而不是更现代的-Fetch？" class="headerlink" title="Axios 为什么使用 XMLHttpRequest 而不是更现代的 Fetch？"></a>Axios 为什么使用 XMLHttpRequest 而不是更现代的 Fetch？</h4><ol><li><strong>历史原因</strong>：Axios 于 2014 年开始维护，而 Promise 和 Fetch 是在 ES6（2015 年）中引入的，因此 Axios 的 Promise 支持也是在 2015 年才加上的。</li><li><strong>兼容性</strong>：XMLHttpRequest 兼容性更高，支持旧版本浏览器。</li><li><strong>功能</strong>：XMLHttpRequest 提供的底层功能更多。Axios 封装了 XMLHttpRequest，保留了底层功能的同时实现了类似 Fetch 的简洁语法。</li><li><strong>技术更新</strong>：从 v0.22.0 开始，Axios 支持使用 Fetch API 的 <code>AbortController</code> 实现请求取消功能，替换了之前的 <code>CancelToken</code>。</li></ol><hr><h3 id="AJAX（Web-开发技术）"><a href="#AJAX（Web-开发技术）" class="headerlink" title="AJAX（Web 开发技术）"></a>AJAX（Web 开发技术）</h3><ol><li><strong>AJAX</strong>（Asynchronous JavaScript And XML）是一种 Web 开发技术，允许在不重新加载整个页面的情况下通过异步 HTTP 请求从服务器获取内容，并更新页面的相关部分。</li><li>最早 AJAX 是通过使用 XMLHttpRequest 实现的，但现代 Web 应用更倾向于使用 Fetch API 来实现 AJAX。</li><li><strong>AJAX 的本质</strong>：AJAX 指的是通过 JavaScript 进行异步 HTTP 请求，而不是特定的工具或库。无论是 XMLHttpRequest、Fetch API 还是 Axios 都可以实现 AJAX 功能。</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>前后端通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XMLHttpRequest</tag>
      
      <tag>Fetch</tag>
      
      <tag>Axios</tag>
      
      <tag>AJAX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前后端的流式传输</title>
    <link href="/2024/11/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93/"/>
    <url>/2024/11/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<p>在现代的 Web 开发中，前后端分离已成常态。随着实时需求的增加，前后端数据的流式传输（Streaming）技术成为一种重要手段，提升了用户体验的流畅性和数据交互的实时性。本文将简要介绍流式传输的概念、常用场景及其优势。</p><h3 id="什么是流式传输？"><a href="#什么是流式传输？" class="headerlink" title="什么是流式传输？"></a>什么是流式传输？</h3><p>流式传输是一种持续发送数据的方式，不同于传统的请求-响应模式，数据可以在源和接收端间建立持续的连接，数据片段实时传输到客户端，极大减少了等待时间。适用于大文件、视频流、实时数据更新等场景。</p><h3 id="常用技术及应用场景"><a href="#常用技术及应用场景" class="headerlink" title="常用技术及应用场景"></a>常用技术及应用场景</h3><ol><li><strong>WebSocket</strong>：用于实现双向通信，适合实时聊天、在线游戏等场景。</li><li><strong>Server-Sent Events (SSE)</strong> ：端推送消息给客户端，适用于实时通知和状态更新。</li><li><strong>HTTP&#x2F;2 流</strong>：多路复用，支持多个数据流，适合文件传输和流式加载页面内容。</li></ol><h3 id="流式传输的优势"><a href="#流式传输的优势" class="headerlink" title="流式传输的优势"></a>流式传输的优势</h3><ul><li><strong>降低延迟</strong>：数据分块传输，实时更新，减少延迟。</li><li><strong>减少资源占用</strong>：在需要时传输数据而非一次性加载，节省流量和内存。</li><li><strong>提升用户体验</strong>：内容逐步呈现，增强交互体验。</li></ul><p>流式传输的技术结合前后端架构优化，不仅能满足高并发需求，还能提升用户的互动体验，是现代 Web 开发中的关键技术之一。</p><h3 id="nginx-支持"><a href="#nginx-支持" class="headerlink" title="nginx 支持"></a>nginx 支持</h3><p>Nginx 是通过缓存响应内容来处理请求的。当 Nginx 接收到完整的响应后，才会将其发送给客户端，因此默认是不支持流式响应，需要手动开启。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># nginx关键配置</span><br><span class="hljs-attribute">proxy_cache</span> <span class="hljs-literal">off</span>;  <span class="hljs-comment"># 关闭缓存；默认是：on</span><br><span class="hljs-attribute">proxy_buffering</span> <span class="hljs-literal">off</span>;  <span class="hljs-comment"># 关闭代理缓冲；默认是：on</span><br><span class="hljs-attribute">chunked_transfer_encoding</span> <span class="hljs-literal">on</span>;  <span class="hljs-comment"># 开启分块传输编码</span><br></code></pre></td></tr></table></figure><h3 id="前端相关代码"><a href="#前端相关代码" class="headerlink" title="前端相关代码"></a>前端相关代码</h3><p><a href="https://github.com/KathyLab/mini-chatgpt">Koa+React 代码参考来自</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PostStream</span>(<span class="hljs-params">controller, url, data</span>) &#123;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-title class_">Cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-title class_">Authorization</span>: token,<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),<br>    <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span><br>  &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> !== <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-keyword">throw</span> &#123; response &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> response.<span class="hljs-property">body</span><br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(procReqError)<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; userPrompt prompt 问题</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; updateMsgFun 更新消息的函数 接收一个参数，就是当前回复的所有文本</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">streamingReply</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">userPrompt, updateMsgFun</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>()<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title class_">PostStream</span>(<br>      controller,<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;apiPrefix&#125;</span>/getAnswerByAI?stream=true`</span>,<br>      &#123; userPrompt &#125;<br>    )<br><br>    <span class="hljs-comment">// 得到流</span><br>    <span class="hljs-keyword">const</span> reader = response.<span class="hljs-title function_">getReader</span>()<br><br>    <span class="hljs-keyword">let</span> streamData = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; done, value &#125; = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>()<br>      <span class="hljs-keyword">if</span> (done) &#123;<br>        controller.<span class="hljs-title function_">abort</span>()<br>        <span class="hljs-keyword">break</span><br>      &#125;<br><br>      <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>().<span class="hljs-title function_">decode</span>(value)<br>      <span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/data:\s*(.*?)\s*\n\n/g</span><br>      <span class="hljs-keyword">const</span> match = text.<span class="hljs-title function_">matchAll</span>(pattern)<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> m <span class="hljs-keyword">of</span> match) &#123;<br>        <span class="hljs-keyword">if</span> (m[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;[DONE]&#x27;</span>) &#123;<br>          controller.<span class="hljs-title function_">abort</span>() <span class="hljs-comment">// 断开连接</span><br>          <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">const</span> s = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(m[<span class="hljs-number">1</span>])<br><br>        streamData += s.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">delta</span>.<span class="hljs-property">content</span><br>        <span class="hljs-title function_">updateMsgFun</span>(streamData)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Server-Sent-Events-SSE-实现"><a href="#Server-Sent-Events-SSE-实现" class="headerlink" title="Server-Sent Events (SSE) 实现"></a>Server-Sent Events (SSE) 实现</h3><h4 id="前端关键点："><a href="#前端关键点：" class="headerlink" title="前端关键点："></a>前端关键点：</h4><ul><li><strong>连接创建</strong>：使用 <code>new EventSource(url)</code> 创建 SSE 连接。SSE 自动重连，但要确保服务端对重连有支持。</li><li><strong>事件处理</strong>：通过 <code>onmessage</code> 接收数据。也可以自定义事件类型，通过 <code>addEventListener</code> 监听。</li><li><strong>错误处理</strong>：监听 <code>onerror</code> 事件，处理网络错误或服务端错误。</li></ul><h4 id="后端关键点："><a href="#后端关键点：" class="headerlink" title="后端关键点："></a>后端关键点：</h4><ul><li><strong>持续输出</strong>：SSE 是单向的（从服务器到客户端），后端需要持续输出流数据，例如 <code>res.write(&quot;data: message\n\n&quot;)</code>。</li><li><strong>内容类型</strong>：确保响应头 <code>Content-Type</code> 设置为 <code>text/event-stream</code>。</li><li><strong>保持连接</strong>：设置合适的连接超时，确保连接长时间维持（如适当的 <code>keep-alive</code> 设置）。</li></ul><h4 id="易错点："><a href="#易错点：" class="headerlink" title="易错点："></a>易错点：</h4><ul><li><strong>不设置响应头</strong>：若没有正确设置 <code>Content-Type</code>，浏览器无法识别 SSE 数据流。</li><li><strong>丢失数据</strong>：若服务器重启或断开，客户端可能丢失数据，因此需要考虑容错策略。</li><li><strong>连接超时</strong>：部分服务器可能会断开空闲连接，要设置合适的超时策略。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>前后端通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Streaming</tag>
      
      <tag>SSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓Android端font-weight不生效</title>
    <link href="/2024/10/20/%E5%AE%89%E5%8D%93Android%E7%AB%AFfont-weight%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    <url>/2024/10/20/%E5%AE%89%E5%8D%93Android%E7%AB%AFfont-weight%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><blockquote><p>一段文本设置了 font-weight，但是在移动端中的浏览器中不显示加粗</p></blockquote><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p><code>font-weight：normal | bold | lighter | bolder | number（1，1000）</code></p><p><code>font-weight</code> 数值采取离散式定义（使用 100 的整倍数）。数值为实数，非 100 的整数倍的值将被四舍五入转换为 100 的整倍数，遇到 50 时，将向上转换，如 150 将转换为 200。</p><p>实际上，所有这些数值关键字浏览器都是支持的，之所以没有看到任何粗细的变化，是因为某些系统里面<strong>缺乏对应粗细的字体</strong>。</p><h3 id="回退机制"><a href="#回退机制" class="headerlink" title="回退机制"></a>回退机制</h3><p>如果指定的权重值不可用，则使用以下规则来确定实际呈现的权重：</p><ul><li>如果指定的权重值在 400 和 500 之间（包括 400 和 500）：<ul><li>按升序查找指定值与 500 之间的可用权重；</li><li>如果未找到匹配项，按降序查找小于指定值的可用权重；</li><li>如果未找到匹配项，按升序查找大于 500 的可用权重。</li></ul></li><li>如果指定值小于 400，按降序查找小于指定值的可用权重。如果未找到匹配项，按升序查找大于指定值的可用权重（先尽可能的小，再尽可能的大）。</li><li>如果指定值大于 500，按升序查找大于指定值的可用权重。如果未找到匹配项，按降序查找小于指定值的可用权重（先尽可能的大，再尽可能的小）。</li></ul><p>以上策略意味着，如果一个字体只有 normal 和 bold 两种粗细值选择，指定粗细值为 100-500 时，实际渲染时将使用 normal，指定粗细值为 501-900 时，实际渲染时将使用 bold 。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ul><li><p>移动端和 PC 端的字体都设置成通用，即 <code>font-weight: normal</code> 或者 <code>font-weight: bold</code>;</p><p>优点：这两个值各种字体都可以取到，兼容性好，改动简单</p><p>缺点：PC 端字体粗细没有明确划分，可能和设计图纸不同</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>兼容性</tag>
      
      <tag>Android</tag>
      
      <tag>font-weight</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ios系统伪类:active不生效</title>
    <link href="/2024/10/20/ios%E7%B3%BB%E7%BB%9F%E4%BC%AA%E7%B1%BB-active%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    <url>/2024/10/20/ios%E7%B3%BB%E7%BB%9F%E4%BC%AA%E7%B1%BB-active%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><blockquote><p>在用 h5 写前端页面适配 iOS 的 webview 发现一些兼容性问题</p></blockquote><ul><li>在 PC 浏览器中，按下鼠标即可激活元素 :active 生效，松开鼠标就会取消激活状态 :active 失效</li><li>在移动浏览器中，手指按下就会激活 :active 状态，手指松开就会取消激活状态 :active 失效</li><li>在 iOS 的 webview 时候发现点击效果 active 失效</li></ul><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>在 ios 系统下如果该元素没有绑定 touchstart, touchmove, 或 touchend，元素就不会进入 :active 状态。 可以通过 addEventListener 或 ontouchstart&#x3D;“” 的方式给它（或者它的祖先元素）添加这个事件</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ul><li>在 body 标签上添加 ontouchstart 事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">ontouchstart</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在元素节点上添加 ontouchstart 事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ontouchstart</span>=<span class="hljs-string">&quot;() =&gt; &#123;&#125;&quot;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>用 js 给全局加一个 touchstart 事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;, <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
      <tag>兼容性</tag>
      
      <tag>active</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css 文本换行</title>
    <link href="/2024/06/12/css-%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/"/>
    <url>/2024/06/12/css-%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>常见的 css 文本换行方式</strong></p><ul><li><p><code>overflow-wrap</code></p></li><li><p><code>word-break</code></p></li><li><p><code>white-space</code></p></li><li><p><code>hyphens</code></p></li><li><p><code>line-break</code></p></li></ul><h2 id="1-overflow-wrap"><a href="#1-overflow-wrap" class="headerlink" title="1. overflow-wrap"></a>1. <code>overflow-wrap</code></h2><p><code>overflow-wrap</code> 用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow-wrap</span>: normal;<br><span class="hljs-attribute">overflow-wrap</span>: anywhere;<br><span class="hljs-attribute">overflow-wrap</span>: break-word;<br></code></pre></td></tr></table></figure><p><code>normal</code>：使用默认的断行规则；对于英语和其他相关书写系统，换行符将出现在空格和连字符处</p><p><code>anywhere</code>：将在字符串之间的任意点来进行中断，如果行中没有其他可接受的断点，则不可断的字符串（如长词或 URL）可能会在任何时候换行。在断点处不会插入连字符。在计算最小内容内在大小时（min-content），会考虑由单词换行引入的软换行机会。</p><p><code>break-word</code>：与 anywhere 值相同，如果行中没有其他可接受的断点，则允许在任意点将通常不可断的单词换行，但在计算最小内容内在大小时不考虑断字引入的软换行机会。</p><blockquote><p><em>tips</em>：<code>overflow-wrap</code> 属性就是原来的<code>word-wrap</code>。<code>word-wrap</code>最初是一个没有前缀的 Microsoft 扩展。它不是 CSS 标准的一部分，尽管大多数浏览器都使用 word-wrap 这个名称来实现它。根据 CSS3 规范草案，浏览器应将<code>word-wrap</code>视为<code>overflow-wrap</code>属性的遗留名称别名，以确保兼容性。</p></blockquote><h2 id="2-word-break"><a href="#2-word-break" class="headerlink" title="2. word-break"></a>2. <code>word-break</code></h2><p>word-break 属性用于指定怎样在单词内进行断行。我们可以使用该属性在内容发生溢出的确切位置拆分单词并将其换行到下一行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">word-break</span>: normal;<br><span class="hljs-attribute">word-break</span>: break-all;<br><span class="hljs-attribute">word-break</span>: keep-all;<br><span class="hljs-attribute">word-break</span>: break-word;<br></code></pre></td></tr></table></figure><p><code>normal</code>：使用默认的断行规则</p><p><code>break-all</code>：对于 non-CJK (CJK 指中文&#x2F;日文&#x2F;韩文) 文本，可在任意字符间断行，CJK 书写系统有自己的应用断点规则</p><p><code>keep-all</code>：CJK 文本不断行。Non-CJK 文本表现同 <code>normaldsa</code></p><p><code>break-word</code>：效果是<code>word-break: normal</code> 和 <code>overflow-wrap: anywhere</code> 的结合，已废弃 🗑，但仍可以使用</p><h2 id="3-white-space"><a href="#3-white-space" class="headerlink" title="3. white-space"></a>3. <code>white-space</code></h2><p><code>white-space</code> 属性是用来设置如何处理元素中的空白，空白字符是否合并，以及如何合并，是否换行，以及如何换行</p><p><code>white-space</code> 属性可以被指定为从下面的值列表中选择的单个关键字，或者是表示 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/white-space-collapse"><code>white-space-collapse</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-wrap"><code>text-wrap</code></a> 属性的简写的两个值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">white-space</span>: normal;<br><span class="hljs-attribute">white-space</span>: nowrap;<br><span class="hljs-attribute">white-space</span>: pre;<br><span class="hljs-attribute">white-space</span>: pre-wrap;<br><span class="hljs-attribute">white-space</span>: pre-line;<br><span class="hljs-attribute">white-space</span>: break-spaces;<br></code></pre></td></tr></table></figure><p><code>normal</code>：连续的空白符会被合并。源码中的换行符会被当作空白符来处理。并根据填充行框盒子的需要来换行<br><code>nowrap</code>：和 normal 一样合并空白符，但阻止源码中的文本换行<br><code>pre</code>：连续的空白符会被保留。仅在遇到换行符或 <code>&lt;br&gt;</code> 元素时才会换行<br><code>pre-wrap</code>：连续的空白符会被保留。在遇到换行符或 <code>&lt;br&gt;</code> 元素时，或者根据填充行框盒子的需要换行<br><code>pre-line</code>：连续的空白符会被合并。在遇到换行符或 <code>&lt;br&gt;</code> 元素时，或者根据填充行框盒子的需要换行。<br><code>break-spaces</code>：与 <code>pre-wrap</code> 的行为相同，除了：</p><ul><li>任何保留的空白序列总是占用空间，包括行末的。</li><li>每个保留的空白字符后（包括空白字符之间）都可以被截断。</li><li>这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容——<code>min-content</code>——大小和最大内容——<code>max-content</code>——大小）。</li></ul><table><thead><tr><th align="center"></th><th align="center">换行符</th><th align="center">空格和制表符</th><th align="center">文本换行</th><th align="center">行末空格</th><th align="center">行末的其他空白分隔符</th></tr></thead><tbody><tr><td align="center"><code>normal</code></td><td align="center">合并</td><td align="center">合并</td><td align="center">换行</td><td align="center">移除</td><td align="center">挂起</td></tr><tr><td align="center"><code>nowrap</code></td><td align="center">合并</td><td align="center">合并</td><td align="center">不换行</td><td align="center">移除</td><td align="center">挂起</td></tr><tr><td align="center"><code>pre</code></td><td align="center">保留</td><td align="center">保留</td><td align="center">不换行</td><td align="center">保留</td><td align="center">不换行</td></tr><tr><td align="center"><code>pre-wrap</code></td><td align="center">保留</td><td align="center">保留</td><td align="center">换行</td><td align="center">挂起</td><td align="center">挂起</td></tr><tr><td align="center"><code>pre-line</code></td><td align="center">保留</td><td align="center">合并</td><td align="center">换行</td><td align="center">移除</td><td align="center">挂起</td></tr><tr><td align="center"><code>break-spaces</code></td><td align="center">保留</td><td align="center">保留</td><td align="center">换行</td><td align="center">换行</td><td align="center">换行</td></tr></tbody></table><h2 id="4-hyphens"><a href="#4-hyphens" class="headerlink" title="4. hyphens"></a>4. <code>hyphens</code></h2><p><strong><code>hyphens</code></strong> 告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。</p><p>连字规则具有语言特定性。在 HTML 中，语言由 lang 属性决定，浏览器只会在当前属性存在且有合适的连字字典可用的情况使用连字进行连接。在 XML 中，必须使用 <code>xml:lang</code> 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">hyphens</span>: none;<br><span class="hljs-attribute">hyphens</span>: manual;<br><span class="hljs-attribute">hyphens</span>: auto;<br></code></pre></td></tr></table></figure><p><code>none</code>：即便单词内有建议换行点也不会在那里换行。只会在空白符处换行。<br><code>manual</code>：只有当单词内存在建议换行点时，才会在该位置断开单词并使用连字符换行。<br><code>auto</code>：浏览器可以自由地在适当的断字点自动断词。</p><p><strong>建议换行点</strong><br>有两个 Unicode 字符可以用于在文本中手动指定可能的换行点：</p><p>U+2010（HYPHEN）<br>“硬”连字符表示一个可见的换行点。即使在指定的位置没有真正换行，连字符仍然会显示出来。</p><p>U+00AD（SHY）<br>一个不可见的“软”连字符。此字符不会在屏幕上显示出来，而是表示在必要时浏览器可能会在该位置断开单词并出现连字符。在 HTML 中，可以使用 <code>&amp;shy;</code> 来插入软连字符。</p><h2 id="5-line-break"><a href="#5-line-break" class="headerlink" title="5. line-break"></a>5. <code>line-break</code></h2><p><code>line-break</code>属性可以用来处理如何断开带有<strong>标点符号</strong>的中文、日文或韩文（CJK）文本的行。简而言之，该属性可以用来处理过长的标点符号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">line-break</span>: auto;<br><span class="hljs-attribute">line-break</span>: loose;<br><span class="hljs-attribute">line-break</span>: normal;<br><span class="hljs-attribute">line-break</span>: strict;<br><span class="hljs-attribute">line-break</span>: anywhere;<br></code></pre></td></tr></table></figure><p><code>auto</code>：使用默认的断行规则分解文本<br><code>loose</code>：使用尽可能松散（least restrictive）的断行规则分解文本。一般用于短行的情况，如报纸<br><code>normal</code>：使用最一般（common）的断行规则分解文本<br><code>strict</code>：使用最严格（stringent）的断行原则分解文本<br><code>anywhere</code>：可以使用 <code>line-break: anywhere</code> 来使长标点符号进行换行</p><p><strong>参考</strong></p><blockquote><p><a href="https://juejin.cn/post/7111880813230161933">https://juejin.cn/post/7111880813230161933</a><br><a href="https://codersblock.com/blog/deep-dive-into-text-wrapping-and-word-breaking/">https://codersblock.com/blog/deep-dive-into-text-wrapping-and-word-breaking/</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">https://developer.mozilla.org/zh-CN/docs/Web/CSS</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css 隐藏滚动条</title>
    <link href="/2024/04/19/css-%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
    <url>/2024/04/19/css-%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>CSS 隐藏滚动条并且同时可以滚动内容</strong></p><h3 id="IE-10"><a href="#IE-10" class="headerlink" title="IE 10+"></a>IE 10+</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-ms-<span class="hljs-attribute">overflow</span>-style: none; <span class="hljs-comment">/* IE 10+ */</span><br></code></pre></td></tr></table></figure><h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">scrollbar-width</span>: none; <span class="hljs-comment">/* Firefox */</span><br></code></pre></td></tr></table></figure><h3 id="Chrome-和-Safari"><a href="#Chrome-和-Safari" class="headerlink" title="Chrome 和 Safari"></a>Chrome 和 Safari</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">::-webkit-scrollbar &#123;<br>  <span class="hljs-attribute">display</span>: none; <span class="hljs-comment">/* Chrome Safari */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS正则表达式</title>
    <link href="/2023/11/30/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/11/30/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>正则是匹配模式，要么匹配字符，要么匹配位置</strong></p><h2 id="第一章-正则表达式字符匹配攻略"><a href="#第一章-正则表达式字符匹配攻略" class="headerlink" title="第一章 正则表达式字符匹配攻略"></a>第一章 正则表达式字符匹配攻略</h2><h3 id="1-两种模糊匹配"><a href="#1-两种模糊匹配" class="headerlink" title="1. 两种模糊匹配"></a>1. 两种模糊匹配</h3><blockquote><p>正则表达式之所以强大，是因为其能实现模糊匹配。</p><p>而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊。</p></blockquote><p><strong>1.1 横向模糊匹配</strong></p><p>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。</p><p>其实现的方式是使用量词。譬如<code>&#123;m,n&#125;</code>，表示连续出现最少 m 次，最多 n 次。</p><p><strong>1.2 纵向模糊匹配</strong></p><p>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。</p><p>其实现的方式是使用字符组。譬如<code>[abc]</code>，表示该字符是可以字符“a”、“b”、“c”中的任何一个。</p><h3 id="2-字符组"><a href="#2-字符组" class="headerlink" title="2. 字符组"></a>2. 字符组</h3><p><strong>2.1 范围表示法</strong></p><p><code>[0-9a-zA-Z]</code>，用连字符<code>-</code>来省略和简写。</p><p><code>[-az]</code>或<code>[az-]</code>或<code>[a\-z]</code>，匹配“a”、“-”、“z”这三者中任意一个字符</p><p><strong>2.2 排除字符组</strong></p><p>纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是”a”、”b”、”c”。</p><p>排除字符组（反义字符组）的概念。例如<code>[^abc]</code></p><p><strong>2.3 常见的简写形式</strong></p><blockquote><p>**<code>\d</code>**就是<code>[0-9]</code>。表示是一位数字。记忆方式：其英文是 digit（数字）。</p><p>**<code>\D</code>**就是<code>[^0-9]</code>。表示除数字外的任意字符。</p><p>**<code>\w</code>**就是<code>[0-9a-zA-Z_]</code>。表示数字、大小写字母和下划线。记忆方式：w 是 word 的简写，也称单词字符。</p><p>**<code>\W</code>**是<code>[^0-9a-zA-Z_]</code>。非单词字符。</p><p>**<code>\s</code>**是<code>[ \t\v\n\r\f]</code>。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s 是 space character 的首字母。</p><p>**<code>\S</code>**是<code>[^ \t\v\n\r\f]</code>。 非空白符。</p><p>**<code>.</code>**就是<code>[^\n\r\u2028\u2029]</code>。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。</p><p>匹配任意字符，可以用<code>[\d\D]</code>、<code>[\w\W]</code>、<code>[\s\S]</code>或者<code>[^]</code></p></blockquote><h3 id="3-量词"><a href="#3-量词" class="headerlink" title="3. 量词"></a>3. 量词</h3><p>量词也称重复，掌握<code>&#123;m,n&#125;</code>的准确含义后，只需要记住一些简写形式</p><p><strong>3.1 简写形式</strong></p><blockquote><p><code>&#123;m,&#125;</code> 表示至少出现 m 次。</p><p><code>&#123;m&#125;</code> 等价于<code>&#123;m,m&#125;</code>，表示出现 m 次。</p><p><code>?</code> 等价于<code>&#123;0,1&#125;</code>，表示出现或者不出现。记忆方式：问号的意思表示，有吗？</p><p><code>+ </code>等价于<code>&#123;1,&#125;</code>，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。</p><p><code>*</code> 等价于<code>&#123;0,&#125;</code>，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。</p></blockquote><p><strong>3.2 贪婪匹配和惰性匹配</strong></p><p>贪婪匹配，会尽可能多的匹配；惰性匹配，就是尽可能少的匹配</p><p>通过在<strong>量词</strong>后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：</p><blockquote><p><code>&#123;m,n&#125;?</code> &gt; <code>&#123;m,&#125;?</code> &gt; <code>??</code> &gt; <code>+?</code> &gt; <code>*?</code></p></blockquote><h3 id="4-多选分支"><a href="#4-多选分支" class="headerlink" title="4. 多选分支"></a>4. 多选分支</h3><p>一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一</p><p>具体形式：<code>(p1|p2|p3)</code>，其中<code>p1</code>、<code>p2</code>和<code>p3</code>是子模式，用<code>|</code>（管道符）分隔，表示其中任何之一。</p><blockquote><p>分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了</p></blockquote><h2 id="第二章-正则表达式位置匹配攻略"><a href="#第二章-正则表达式位置匹配攻略" class="headerlink" title="第二章 正则表达式位置匹配攻略"></a>第二章 正则表达式位置匹配攻略</h2><h3 id="1-什么是位置？"><a href="#1-什么是位置？" class="headerlink" title="1. 什么是位置？"></a>1. 什么是位置？</h3><blockquote><p>位置是相邻字符之间的位置</p></blockquote><h3 id="2-如何匹配位置？"><a href="#2-如何匹配位置？" class="headerlink" title="2. 如何匹配位置？"></a>2. 如何匹配位置？</h3><blockquote><p>在 ES5 中，共有 6 个锚字符：</p><p><code>^</code> <code>$</code> <code>\b</code> <code>\B</code> <code>(?=p)</code> <code>(?!p)</code></p></blockquote><p><strong>2.1 ^和$</strong></p><p><code>^</code>（脱字符）匹配开头，在多行匹配中匹配行开头</p><p><code>$</code>（美元符号）匹配结尾，在多行匹配中匹配行结尾</p><p><strong>2.2 \b 和\B</strong></p><p><code>\b</code>是单词边界，具体就是<code>\w</code>和<code>\W</code>之间的位置，也包括<code>\w</code>和<code>^</code>之间的位置，也包括<code>\w</code>和<code>$</code>之间的位置</p><p><code>\B</code>就是<code>\b</code>的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉<code>\b</code>，剩下的都是<code>\B</code>的，具体说来就是<code>\w</code>与<code>\w</code>、<code>\W</code>与<code>\W</code>、<code>^</code>与<code>\W</code>，<code>\W</code>与<code>$</code>之间的位置</p><p><strong>2.3 (?&#x3D;p)和(?!p)</strong></p><p><code>(?=p)</code>，其中<code>p</code>是一个子模式，即<code>p</code>前面的位置，positive lookahead，正向先行断言</p><p><code>(?!p)</code>就是<code>(?=p)</code>的反面意思，negative lookahead，负向先行断言</p><p>ES6 中，还支持 positive lookbehind 和 negative lookbehind，即<code>(?&lt;=p)</code>和<code>(?&lt;!p)</code></p><h3 id="3-位置的特性"><a href="#3-位置的特性" class="headerlink" title="3. 位置的特性"></a>3. 位置的特性</h3><p>对于位置的理解，我们可以理解成空字符””</p><p>比如”hello”字符串等价于如下的形式：</p><p><code>&quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;o&quot; + &quot;&quot;;</code></p><p>也等价于：</p><p><code>&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot;</code></p><p>把<code>/^hello$/</code>写成<code>/^^hello?$/</code>，是没有任何问题的</p><p>字符之间的位置，可以写成多个；把位置理解空字符，是对位置非常有效的理解方式</p><h2 id="第三章-正则表达式括号的作用"><a href="#第三章-正则表达式括号的作用" class="headerlink" title="第三章 正则表达式括号的作用"></a>第三章 正则表达式括号的作用</h2><h3 id="1-分组和分支结构"><a href="#1-分组和分支结构" class="headerlink" title="1. 分组和分支结构"></a>1. 分组和分支结构</h3><p><strong>1.1 分组</strong></p><p>括号是提供分组功能，使量词<code>+</code>作用于“ab”这个整体</p><p>匹配连续出现的“ab”，需要使用<code>/(ab)+/</code></p><p><strong>1.2 分支结构</strong></p><p>在多选分支结构<code>(p1|p2)</code>中，此处括号的作用提供了子表达式的所有可能</p><h3 id="2-引用分组"><a href="#2-引用分组" class="headerlink" title="2. 引用分组"></a>2. 引用分组</h3><p><strong>2.1 提取数据</strong></p><p>比如提取出年、月、日，可以这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;2017-06-12&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">match</span>(regex))<br><span class="hljs-comment">// =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]</span><br></code></pre></td></tr></table></figure><p><code>match</code>返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符<code>g</code>，<code>match</code>返回的数组格式是不一样的）。</p><p>另外也可以使用正则对象的<code>exec</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;2017-06-12&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">exec</span>(string))<br><span class="hljs-comment">// =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]</span><br></code></pre></td></tr></table></figure><p>同时，也可以使用构造函数的全局属性<code>$1</code>至<code>$9</code>来获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;2017-06-12&#x27;</span><br><br>regex.<span class="hljs-title function_">test</span>(string) <span class="hljs-comment">// 正则操作即可，例如</span><br><span class="hljs-comment">//regex.exec(string);</span><br><span class="hljs-comment">//string.match(regex);</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>) <span class="hljs-comment">// &quot;2017&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$2</span>) <span class="hljs-comment">// &quot;06&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$3</span>) <span class="hljs-comment">// &quot;12&quot;</span><br></code></pre></td></tr></table></figure><p><strong>2.2 替换</strong></p><p>比如，想把 yyyy-mm-dd 格式，替换成 mm&#x2F;dd&#x2F;yyyy 怎么做？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;2017-06-12&#x27;</span><br><span class="hljs-keyword">var</span> result = string.<span class="hljs-title function_">replace</span>(regex, <span class="hljs-string">&#x27;$2/$3/$1&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-comment">// =&gt; &quot;06/12/2017&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>replace</code>中的，第二个参数里用<code>$1</code>、<code>$2</code>、<code>$3</code>指代相应的分组。等价于如下的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;2017-06-12&#x27;</span><br><span class="hljs-keyword">var</span> result = string.<span class="hljs-title function_">replace</span>(regex, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$2</span> + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$3</span> + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-comment">// =&gt; &quot;06/12/2017&quot;</span><br></code></pre></td></tr></table></figure><p>也等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;2017-06-12&#x27;</span><br><span class="hljs-keyword">var</span> result = string.<span class="hljs-title function_">replace</span>(regex, <span class="hljs-keyword">function</span> (<span class="hljs-params">match, year, month, day</span>) &#123;<br>  <span class="hljs-keyword">return</span> month + <span class="hljs-string">&#x27;/&#x27;</span> + day + <span class="hljs-string">&#x27;/&#x27;</span> + year<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-comment">// =&gt; &quot;06/12/2017&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-反向引用"><a href="#3-反向引用" class="headerlink" title="3. 反向引用"></a>3. 反向引用</h3><p>写一个正则支持匹配如下三种格式：</p><blockquote><p>2016-06-12</p><p>2016&#x2F;06&#x2F;12</p><p>2016.06.12</p></blockquote><p><code>const regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</code></p><p>注意里面的<code>\1</code>，表示的引用之前的那个分组<code>(-|\/|\.)</code>。不管它匹配到什么（比如-），<code>\1</code>都匹配那个同样的具体某个字符</p><p>我们知道了<code>\1</code>的含义后，那么<code>\2</code>和<code>\3</code>的概念也就理解了，即分别指代第二个和第三个分组</p><p><strong>3.1 括号嵌套怎么办？</strong></p><p>以左括号（开括号）为准</p><p><strong>3.2 \10 表示什么呢？</strong></p><p><code>\10</code>是表示第 10 个分组，还是<code>\1</code>和<code>0</code>呢? 表示<strong>第 10 个分组</strong></p><p><strong>3.3 引用不存在的分组会怎样？</strong></p><p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如<code>\2</code>，就匹配”\2”。注意”\2”表示对”2”进行了转意。</p><h3 id="4-非捕获分组"><a href="#4-非捕获分组" class="headerlink" title="4. 非捕获分组"></a>4. 非捕获分组</h3><p>之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。</p><p>如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。此时可以使用非捕获分组<code>(?:p)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/(?:ab)+/g</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;ababa abbb ababab&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">match</span>(regex))<br><span class="hljs-comment">// =&gt; [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;]</span><br></code></pre></td></tr></table></figure><h2 id="第四章-正则表达式回溯法原理"><a href="#第四章-正则表达式回溯法原理" class="headerlink" title="第四章 正则表达式回溯法原理"></a>第四章 正则表达式回溯法原理</h2><h3 id="1-没有回溯的匹配"><a href="#1-没有回溯的匹配" class="headerlink" title="1. 没有回溯的匹配"></a>1. 没有回溯的匹配</h3><h3 id="2-有回溯的匹配"><a href="#2-有回溯的匹配" class="headerlink" title="2. 有回溯的匹配"></a>2. 有回溯的匹配</h3><h3 id="3-常见的回溯形式"><a href="#3-常见的回溯形式" class="headerlink" title="3. 常见的回溯形式"></a>3. 常见的回溯形式</h3><p>正则表达式匹配字符串的这种方式，有个学名，叫回溯法。</p><p>回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。</p><p>本质上就是深度优先搜索算法。<strong>其中退到之前的某一步这一过程，我们称为“回溯”。</strong>从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，<strong>尝试匹配失败时，接下来的一步通常就是回溯。</strong></p><p>JS 中正则表达式会产生回溯的地方都有哪些?</p><p><strong>3.1 贪婪量词</strong></p><p><strong>3.2 惰性量词</strong></p><p><strong>3.3 分支结构</strong></p><blockquote><p>既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎。</p><p>而 JS 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。</p><p>大部分语言中的正则都是 NFA</p></blockquote><h2 id="第五章-正则表达式的拆分"><a href="#第五章-正则表达式的拆分" class="headerlink" title="第五章 正则表达式的拆分"></a>第五章 正则表达式的拆分</h2><h3 id="1-结构和操作符"><a href="#1-结构和操作符" class="headerlink" title="1. 结构和操作符"></a>1. 结构和操作符</h3><p>JS 正则表达式中，都有哪些结构呢？</p><blockquote><p>字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。</p></blockquote><p>具体含义简要回顾如下：</p><blockquote><p><strong>字面量</strong>，匹配一个具体字符，包括不用转义的和需要转义的。比如 a 匹配字符”a”，又比如<code>\n</code>匹配换行符，又比如<code>\.</code>匹配小数点。</p><p><strong>字符组</strong>，匹配一个字符，可以是多种可能之一，比如<code>[0-9]</code>，表示匹配一个数字。也有<code>\d</code>的简写形式。另外还有反义字符组，表示可以是除了特定字符之外任何一个字符，比如<code>[^0-9]</code>，表示一个非数字字符，也有<code>\D</code>的简写形式。</p><p><strong>量词</strong>，表示一个字符连续出现，比如<code>a&#123;1,3&#125;</code>表示“a”字符连续出现 3 次。另外还有常见的简写形式，比如<code>a+</code>表示“a”字符连续出现至少一次。</p><p><strong>锚点</strong>，匹配一个位置，而不是字符。比如^匹配字符串的开头，又比如<code>\b</code>匹配单词边界，又比如<code>(?=\d)</code>表示数字前面的位置。</p><p><strong>分组</strong>，用括号表示一个整体，比如<code>(ab)+</code>，表示”ab”两个字符连续出现多次，也可以使用非捕获分组<code>(?:ab)+</code>。</p><p><strong>分支</strong>，多个子表达式多选一，比如<code>abc|bcd</code>，表达式匹配”abc”或者”bcd”字符子串。</p><p><strong>反向引用</strong>，比如<code>\2</code>，表示引用第 2 个分组。</p></blockquote><p>其中涉及到的操作符有：</p><blockquote><p>1.转义符 <code>\</code> 2.括号和方括号 <code>(...)</code>、<code>(?:...)</code>、<code>(?=...)</code>、<code>(?!...)</code>、<code>[...]</code> 3.量词限定符 <code>&#123;m&#125;</code>、<code>&#123;m,n&#125;</code>、<code>&#123;m,&#125;</code>、<code>?</code>、<code>*</code>、<code>+</code> 4.位置和序列 <code>^</code> 、<code>$</code>、 <code>\元字符</code>、 <code>一般字符</code><br>\5. 管道符（竖杠）<code>|</code></p></blockquote><p>上面操作符的优先级从上至下，由高到低</p><h3 id="2-注意要点"><a href="#2-注意要点" class="headerlink" title="2. 注意要点"></a>2. 注意要点</h3><p><strong>2.1 匹配字符串整体问题</strong></p><p><code>/^abc|bcd$/</code>和<code>/^(abc|bcd)$/</code></p><p><strong>2.2 量词连缀问题</strong></p><p><code>/^[abc]&#123;3&#125;+$/</code>和<code>/^([abc]&#123;3&#125;)+$/</code></p><p><strong>2.3 元字符转义问题</strong></p><p>所谓元字符，就是正则中有特殊含义的字符</p><p>所有结构里，用到的元字符总结如下：</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">`^`</span> <span class="hljs-string">`$`</span> <span class="hljs-string">`.`</span> <span class="hljs-string">`*`</span> <span class="hljs-string">`+`</span> <span class="hljs-string">`?`</span> <span class="hljs-string">`|`</span> <span class="hljs-string">`\` `</span>/<span class="hljs-string">` `</span>(<span class="hljs-string">` `</span>)<span class="hljs-string">` `</span>[<span class="hljs-string">` `</span>]<span class="hljs-string">` `</span>&#123;<span class="hljs-string">` `</span>&#125;<span class="hljs-string">` `</span>=<span class="hljs-string">` `</span>!<span class="hljs-string">` `</span>:<span class="hljs-string">` `</span>-<span class="hljs-string">` `</span>,<span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></blockquote><p>当匹配上面的字符本身时，可以一律转义</p><p>跟字符组相关的元字符有<code>[]</code>、<code>^</code>、<code>-</code>，因此在会引起歧义的地方进行转义。</p><p>比如<code>=</code> <code>!</code> <code>:</code> <code>-</code> <code>,</code>等符号，只要不在特殊结构中，也不需要转义</p><p>但是，括号需要前后都转义的，如<code>/\(123\)/</code></p><p>至于剩下的<code>^</code> <code>$</code> <code>.</code> <code>*</code> <code>+</code> <code>?</code> <code>|</code> <code>\</code> <code>/</code>等字符，只要不在字符组内，都需要转义的</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文内容均来自《JS 正则迷你书》</p><p>该文章只用于个人学习总结，方便个人记录查看使用，无商业目的</p><p>感谢《JS 正则迷你书》的作者 老姚 – <a href="https://github.com/qdlaoyao/js-regex-mini-book">GitHub 地址</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>script</tag>
      
      <tag>regex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识websocket</title>
    <link href="/2023/11/15/%E5%88%9D%E8%AF%86websocket/"/>
    <url>/2023/11/15/%E5%88%9D%E8%AF%86websocket/</url>
    
    <content type="html"><![CDATA[<h2 id="服务器推送数据到客户端的方案"><a href="#服务器推送数据到客户端的方案" class="headerlink" title="服务器推送数据到客户端的方案"></a>服务器推送数据到客户端的方案</h2><blockquote><p>在用户不感知的情况下，服务器将数据推送给浏览器的技术就是服务器推送技术（comet 技术）</p></blockquote><p>伪服务器推的形式</p><ul><li>轮询，前端代码不断定时发送 HTTP 请求到服务器，常见场景，扫码登陆，比如微信扫码登陆，用的是 HTTP 定时轮询，用户有可能会感受到一到两秒的卡顿</li><li>长轮询，延长请求的超时时间，响应可以做到很及时，比如百度云网盘的登陆界面使用的就是长轮询</li></ul><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><blockquote><p>WebSocket 是一种网络传输协议，可在单个 TCP 连接上进行全双工通信，位于 OSI 模型的应用层。</p><p>HTML5 定义了 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><p>Websocket 使用 ws 或 wss 的统一资源标志符（URI），其中 wss 表示使用了 TLS 的 Websocket。</p><p>WebSocket 协议使用 80 端口，若运行在 TLS 之上时，默认使用 443 端口</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">请求带有特殊的 HTTP Header<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>随机生成的 BASE64 码<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http">响应里也有特殊的 HTTP Header<br><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switahing Protaopls<br><span class="hljs-attribute">Sec-WebSacket-accept</span><span class="hljs-punctuation">: </span>根据请求的 base64 码用公开算法变成的另一段字符串<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br>（101，协议切换）<br></code></pre></td></tr></table></figure><h3 id="websocket-数据帧（Data-Framing）"><a href="#websocket-数据帧（Data-Framing）" class="headerlink" title="websocket 数据帧（Data Framing）"></a>websocket 数据帧（Data Framing）</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"> 0                   1                   2                   3<br> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>+-+-+-+-+-------+-+-------------+-------------------------------+<br>|<span class="hljs-string">F</span>|<span class="hljs-string">R</span>|<span class="hljs-string">R</span>|<span class="hljs-string">R</span>|<span class="hljs-string"> opcode</span>|<span class="hljs-string">M</span>|<span class="hljs-string"> Payload len </span>|<span class="hljs-string">    Extended payload length    </span>|<br>|<span class="hljs-string">I</span>|<span class="hljs-string">S</span>|<span class="hljs-string">S</span>|<span class="hljs-string">S</span>|<span class="hljs-string">  (4)  </span>|<span class="hljs-string">A</span>|<span class="hljs-string">     (7)     </span>|<span class="hljs-string">             (16/64)           </span>|<br>|<span class="hljs-string">N</span>|<span class="hljs-string">V</span>|<span class="hljs-string">V</span>|<span class="hljs-string">V</span>|<span class="hljs-string">       </span>|<span class="hljs-string">S</span>|<span class="hljs-string">             </span>|<span class="hljs-string">   (if payload len==126/127)   </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string">1</span>|<span class="hljs-string">2</span>|<span class="hljs-string">3</span>|<span class="hljs-string">       </span>|<span class="hljs-string">K</span>|<span class="hljs-string">             </span>|<span class="hljs-string">                               </span>|<br>+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +<br>|<span class="hljs-string">     Extended payload length continued, if payload len == 127  </span>|<br>+ - - - - - - - - - - - - - - - +-------------------------------+<br>|<span class="hljs-string">                               </span>|<span class="hljs-string">Masking-key, if MASK set to 1  </span>|<br>+-------------------------------+-------------------------------+<br>|<span class="hljs-string"> Masking-key (continued)       </span>|<span class="hljs-string">          Payload Data         </span>|<br>+-------------------------------- - - - - - - - - - - - - - - - +<br>:                     Payload Data continued ...                :<br>+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +<br>|<span class="hljs-string">                     Payload Data continued ...                </span>|<br>+---------------------------------------------------------------+<br></code></pre></td></tr></table></figure><h2 id="WebSocket-与-HTTP-的区别"><a href="#WebSocket-与-HTTP-的区别" class="headerlink" title="WebSocket 与 HTTP 的区别"></a>WebSocket 与 HTTP 的区别</h2><p>WebSocket 是一种与 HTTP 不同的协议。两者都位于 OSI 模型的应用层，并且都依赖于传输层的 TCP 协议<br><img src="/../img/assets/OSI.png" alt="OSI（Open System Interconnection Model）模型" title="OSI 模型"></p><blockquote><p>websocket 是一种双向通信协议<br>可以通过重用已建立的连接通道将数据从客户端发送到服务器，或者从服务器发送到客户端。连接保持活动状态，直到被客户端或服务器终止。</p><p>几乎所有的实时应用程序(如 (交易，监视，通知) 服务)都使用 websocket 在单个通信通道上接收数据。</p><p>所有经常更新的应用程序都应该使用 websocket，它比 HTTP 连接更快。</p></blockquote><blockquote><p>HTTP 协议是 TCP 协议之上的单向协议，TCP 是面向连接的传输层协议<br>我们可以在获得响应 HTTP 连接关闭后再使用 HTTP 请求方法来创建连接。</p><p>简单的 RESTful 应用程序使用无状态的 HTTP 协议。</p><p>当我们不想在特定时间内保留连接或不重复使用单个连接来传输数据时使用 HTTP ，HTTP 连接的速度比 websocket 慢</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>websocket</tag>
      
      <tag>html5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用指令</title>
    <link href="/2023/10/30/vim%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/10/30/vim%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="Vim-模式"><a href="#Vim-模式" class="headerlink" title="Vim 模式"></a>Vim 模式</h3><ul><li>正常模式（Normal Mode）：默认模式，命令进行操作</li><li>命令模式（Command Mode）：<strong>冒号 :</strong> 起手，可以使用比正常模式更加复杂的命令进行操作</li><li>插入模式（Insert Mode）：主要用于编写文档</li><li>可视模式（Visual Mode）：模拟鼠标选中内容</li></ul><h3 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>a</code></td><td align="center">在光标所在的字符后插入</td></tr><tr><td align="center"><code>A</code></td><td align="center">在光标所在的行尾插入</td></tr><tr><td align="center"><code>i</code></td><td align="center">在光标所在的字符前插入</td></tr><tr><td align="center"><code>I</code></td><td align="center">在光标所在的行首插入</td></tr><tr><td align="center"><code>o</code></td><td align="center">在光标下插入新行</td></tr><tr><td align="center"><code>O</code></td><td align="center">在光标上插入新行</td></tr></tbody></table><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>h j k l</code></td><td align="center">h（左） j（下） k（上） l（右） 移动光标</td></tr><tr><td align="center"></td><td align="center"><strong>在当前行上移动光标</strong></td></tr><tr><td align="center"><code>0</code></td><td align="center">移动到行头</td></tr><tr><td align="center"><code>^</code></td><td align="center">移动到本行的第一个不是 blank 字符</td></tr><tr><td align="center"><code>$</code></td><td align="center">移动到行尾</td></tr><tr><td align="center"><code>g_</code></td><td align="center">移动到本行最后一个不是 blank 字符的位置</td></tr><tr><td align="center"><code>w</code></td><td align="center">光标移动到下一个单词的开头</td></tr><tr><td align="center"><code>e</code></td><td align="center">光标移动到下一个单词的结尾</td></tr><tr><td align="center"><code>fa fb</code></td><td align="center">移动到本行下一个为 a 的字符处，移动到下一个为 b 的字符处</td></tr><tr><td align="center"><code>nfa</code></td><td align="center">移动到本行光标处开始的第 n 个 字符为 a 的地方（n 是 1，2，3，4 … 数字）</td></tr><tr><td align="center"><code>Fa</code></td><td align="center">同 <code>fa</code> 一样，光标移动方向同 <code>fa</code> 相反</td></tr><tr><td align="center"><code>nFa</code></td><td align="center">同 <code>nfa</code> 类似，光标移动方向同 <code>nfa</code>相反</td></tr><tr><td align="center"><code>ta</code></td><td align="center">移动光标至 a 字符的前一个字符</td></tr><tr><td align="center"><code>nta</code></td><td align="center">移动到第 n 个 a 字符的前一个字符处</td></tr><tr><td align="center"><code>Ta</code></td><td align="center">同 <code>ta</code> 移动光标方向相反</td></tr><tr><td align="center"><code>nTa</code></td><td align="center">同 <code>nta</code> 移动光标方向相反</td></tr><tr><td align="center"><code>;</code> 和<code>,</code></td><td align="center">当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用 <code>；</code>可以快速跳转到下一个指定的字符，<code>, </code>是跳到前一个指定的字符</td></tr><tr><td align="center"></td><td align="center"><strong>跨行移动光标</strong></td></tr><tr><td align="center"><code>nG </code></td><td align="center">光标定位到第 n 行的行首</td></tr><tr><td align="center"><code>gg </code></td><td align="center">光标定位到第一行的行首</td></tr><tr><td align="center"><code>G </code></td><td align="center">光标定位到最后一行的行首</td></tr><tr><td align="center"><code>H </code></td><td align="center">光标定位到当前屏幕的第一行行首</td></tr><tr><td align="center"><code>M</code></td><td align="center">光标移动到当前屏幕的中间</td></tr><tr><td align="center"><code>L</code></td><td align="center">光标移动到当前屏幕的尾部</td></tr><tr><td align="center"><code>zt</code></td><td align="center">把当前行移动到当前屏幕的最上方，也就是第一行</td></tr><tr><td align="center"><code>zz</code></td><td align="center">把当前行移动到当前屏幕的中间</td></tr><tr><td align="center"><code>zb</code></td><td align="center">把当前行移动到当前屏幕的尾部</td></tr><tr><td align="center"><code>%</code></td><td align="center">匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上</td></tr><tr><td align="center"><code>*</code> 和 <code>#</code></td><td align="center">匹配光标当前所在的单词，移动光标到下一个（或者上一个）匹配的单词（ <code>*</code> 是下一个，<code>#</code> 是上一个）</td></tr><tr><td align="center"></td><td align="center"><strong>翻页操作</strong></td></tr><tr><td align="center"><code>ctrl+f</code></td><td align="center">查看下一页内容</td></tr><tr><td align="center"><code>ctrl+b</code></td><td align="center">查看上一页内容</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的删除</strong></td></tr><tr><td align="center"><code>dw</code></td><td align="center">删除一个单词</td></tr><tr><td align="center"><code>dnw</code></td><td align="center">删除 n 个单词</td></tr><tr><td align="center"><code>dfa</code></td><td align="center">删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ）</td></tr><tr><td align="center"><code>dnfa</code></td><td align="center">删除光标处到第 n 个 a 的字符处</td></tr><tr><td align="center"><code>dd</code></td><td align="center">删除一整行</td></tr><tr><td align="center"><code>ndd</code></td><td align="center">删除光标处开始的 n 行</td></tr><tr><td align="center"><code>d$</code></td><td align="center">删除光标到本行的结尾</td></tr><tr><td align="center"><code>dH</code></td><td align="center">删除屏幕显示的第一行文本到光标所在的行</td></tr><tr><td align="center"><code>dG</code></td><td align="center">删除光标所在行到文本的结束</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的复制</strong></td></tr><tr><td align="center"><code>y</code></td><td align="center"><code>y</code>是复制的意思</td></tr><tr><td align="center"><code>yw</code></td><td align="center">复制一个单词，还有 <code>ynw</code></td></tr><tr><td align="center"><code>  yfa</code></td><td align="center">复制光标到下一个 a 的字符处,还有<code>ynfa</code></td></tr><tr><td align="center"><code>yy</code></td><td align="center">复制一行，还有 <code>nyy</code></td></tr><tr><td align="center"><code>y$</code></td><td align="center">复制光标到本号的结尾</td></tr><tr><td align="center"><code>yH</code></td><td align="center">复制屏幕显示的第一行文本到光标所在的行</td></tr><tr><td align="center"><code>yG</code></td><td align="center">复制光标所在行到文本的结束</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的黏贴</strong></td></tr><tr><td align="center"><code>p</code></td><td align="center"><code>P</code>是黏贴的意思</td></tr><tr><td align="center"><code>p</code></td><td align="center">在光标后开始黏贴</td></tr><tr><td align="center"><code>P</code></td><td align="center">大写的 P 光标前开始粘贴</td></tr><tr><td align="center"></td><td align="center"><strong>撤销操作和恢复</strong></td></tr><tr><td align="center"><code>u</code></td><td align="center">撤销刚才的操作</td></tr><tr><td align="center"><code>ctrl + r</code></td><td align="center">恢复撤销操作</td></tr><tr><td align="center"></td><td align="center"><strong>删除字符操作和替换</strong></td></tr><tr><td align="center"><code>x</code></td><td align="center">删除光标当前所在的字符</td></tr><tr><td align="center"><code>r</code></td><td align="center">替换掉光标当前所在的字符</td></tr><tr><td align="center"><code>R</code></td><td align="center">替换掉从光标开始以后的所有字符，除非 <code>&lt;ESC &gt;</code> 退出，或者 <code>jj</code> （代替 <code>&lt;ESC&gt;</code>）退出</td></tr><tr><td align="center"></td><td align="center"><strong>大小写转换</strong></td></tr><tr><td align="center"><code>~</code></td><td align="center">将光标下的字母改变大小写</td></tr><tr><td align="center"><code>3~</code></td><td align="center">将光标位置开始的 3 个字母改变其大小写</td></tr><tr><td align="center"><code>g~~</code></td><td align="center">改变当前行字母的大小写</td></tr><tr><td align="center"><code>gUU</code></td><td align="center">将当前行的字母改成大写</td></tr><tr><td align="center"><code>guu</code></td><td align="center">将当前行的字母全改成小写</td></tr><tr><td align="center"><code>3gUU</code></td><td align="center">将从光标开始到下面 3 行字母改成大写</td></tr><tr><td align="center"><code>gUw</code></td><td align="center">将光标下的单词改成大写</td></tr><tr><td align="center"><code>guw</code></td><td align="center">将光标下的单词改成小写</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的重复命令</strong></td></tr><tr><td align="center"><code>.</code></td><td align="center">该命令是重复上一个操作的命令</td></tr><tr><td align="center"><code>n&lt;command&gt;</code></td><td align="center">重复某个命令 n 次</td></tr></tbody></table><h3 id="可视化模式（Visual-mode"><a href="#可视化模式（Visual-mode" class="headerlink" title="可视化模式（Visual-mode)"></a>可视化模式（Visual-mode)</h3><ul><li><code>v</code> 进入 VISUAl 模式</li><li><code>V </code> 进入 VISUAL LINE 模式</li><li><code>Ctrl + v</code> 进入 VISUALBLOCK 模式</li><li>“”，‘’ ，（），{} ，[]（双引号，单引号，小括号，大括号，中括号）,<code>va</code>,<code>vi</code> 会快速选择区域，va 后面会紧跟一个区域结束标志，a 会选中结束符标志，i 就不会</li></ul><h3 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"></td><td align="center"><strong>VIM 的退出</strong></td></tr><tr><td align="center"><code>:w</code></td><td align="center">保存当前对文件的修改，但是不退出文件</td></tr><tr><td align="center"><code>:w!</code></td><td align="center">强制保存但是不退出文件</td></tr><tr><td align="center"><code>:w file</code></td><td align="center">保存当前的文件修改到 file 文件当中</td></tr><tr><td align="center"><code>:q!</code></td><td align="center">退出文件，对文件的修改不做保存</td></tr><tr><td align="center"><code>:qa!</code></td><td align="center">退出所有的文件，对所有的文件修改都不做保存</td></tr><tr><td align="center"><code>:wq</code></td><td align="center">退出文件并保存对文件的修改</td></tr><tr><td align="center"><code>:x</code></td><td align="center">退出文件并保存对文件的修改</td></tr><tr><td align="center"><code>:e file</code></td><td align="center">打开另一个文件</td></tr><tr><td align="center"><code>:e!</code></td><td align="center">放弃对文件的所有修改，恢复文件到上次保存的位置</td></tr><tr><td align="center"><code>:saveas file</code></td><td align="center">另存为 file</td></tr><tr><td align="center"><code>:bn、:bp</code></td><td align="center">当打开多个文件的时候可以输入 <code>:bn</code> 和 <code>:bp</code> 进行上一个文件或者下一个文件的切换</td></tr><tr><td align="center"><code>ZZ</code></td><td align="center">两个大写的 Z (ZZ),这样文件就会快速的保存退出</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的命令模式</strong></td></tr><tr><td align="center"><code>:set nu</code></td><td align="center">该命令会显示行号</td></tr><tr><td align="center"><code>:set nonu</code></td><td align="center">该命令会取消行号</td></tr><tr><td align="center"><code>:n</code></td><td align="center">定位到 n 行</td></tr><tr><td align="center"><code>:set noic</code></td><td align="center">该命令用来区分大小写的查询</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 进行关键字的查找</strong></td></tr><tr><td align="center"><code>/&#123;目标字符串&#125;</code></td><td align="center">查找文本中匹配的目标字符串，查到以后，输入键盘上的 n 会去寻找下一个匹配，N 会去寻找上一个匹配</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 删除多行文本</strong></td></tr><tr><td align="center"><code>:n1,n2d</code></td><td align="center">n1 和 n2 指的是起始行号和结束行号，d 是删除关键字</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 处理文本的替换</strong></td></tr><tr><td align="center"><code>:&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换的标志&#125;</code></td><td align="center"></td></tr><tr><td align="center"><code>&#123;作用范围&#125;</code></td><td align="center">空则为当前行、%为全文、n1,n2 则为 n1 到 n2 的所有行，选区在可视化模式下</td></tr><tr><td align="center"><code>&#123;替换的标志&#125;</code></td><td align="center"><code>g </code>即是替换标志之一，表示全局 <code>global </code>替换（即替换目标的所有出现）<br />空替换标志表示只替换从光标位置开始，目标的第一次出现<br />i 表示大小写不敏感查找，I 表示大小写敏感<br />c 表示需要确认，例如全局查找”zempty”替换为”handsome”并且需要确认</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 执行 Linux 命令</strong></td></tr><tr><td align="center"><code>:!command</code></td><td align="center"><code>!</code> 后面紧跟着 linux 命令</td></tr><tr><td align="center"><code>:r !command</code></td><td align="center">: 后面紧跟着 r , r 后面是空格，紧接着是 !command，并且添加结果至操作文本光标处</td></tr><tr><td align="center"></td><td align="center"><strong>使用 ab</strong></td></tr><tr><td align="center"><code>:ab email xxxx@gmail.com</code></td><td align="center"><code>:</code> 后面的 ab 是关键字 ,该命令执行后，然后切换到编辑模式下,输入 email 会把输入的 email 自动替换成 <a href="mailto:&#x78;&#x78;&#x78;&#120;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#x78;&#x78;&#x78;&#120;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;</a><br />主要是处理频繁输入同样的长串字符串</td></tr></tbody></table><h3 id="VIM-的代码提示功能"><a href="#VIM-的代码提示功能" class="headerlink" title="VIM 的代码提示功能"></a>VIM 的代码提示功能</h3><p>在编辑模式下 ，快捷键 Ctrl+n 或者 Ctrl+p 会有代码提示功能，可以实现快速录入的效果</p><h3 id="VIM-的宏录制"><a href="#VIM-的宏录制" class="headerlink" title="VIM 的宏录制"></a>VIM 的宏录制</h3>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>script标签</title>
    <link href="/2023/10/26/script%E6%A0%87%E7%AD%BE/"/>
    <url>/2023/10/26/script%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="script-引入"><a href="#script-引入" class="headerlink" title="script 引入"></a>script 引入</h2><p><code>&lt;script&gt;</code> 引入 JS 的方式主要有三种：内联、外置，以及动态引入</p><p>动态引入：动态加载的脚本的情况，这种脚本默认为 async 加载形式，可通过将 async 属性设置为 false 来解除，让脚本顺序执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myScript = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>myScript.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;alert(&quot;hello world&quot;)&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(myScript)<br></code></pre></td></tr></table></figure><blockquote><p>通过 innerHTML 方式其实也能添加 script 标签，只是该标签下的 JS 不会运行，如</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="script-加载"><a href="#script-加载" class="headerlink" title="script 加载"></a>script 加载</h2><p>defer（延迟加载）和 async（异步加载）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 会立即加载并执行指定的脚本，js的下载和执行都会阻塞浏览器对HTML的解析</span><br>&lt;script src=<span class="hljs-string">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br><span class="hljs-comment">// 后续文档加载和js加载并行进行即异步，js执行会阻塞浏览器对HTML的解析</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="hljs-comment">// 后续文档加载和js加载并行进行即异步，js执行在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/../img/assets/scriptLoading.png" alt="script加载情况" title="script 脚步加载情况"></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a>type 属性</h3><p>type 属性原本是用来指定 script 脚本的 MIME 类型，默认值是 text&#x2F;javascript，其他值还有诸如：text&#x2F;ecmascript、application&#x2F;ecmascript、application&#x2F;javascript 等等，现代浏览器大多不理会这些值，而是把 type 用来支持 es6 的模块功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip type=<span class="hljs-string">&quot;module&quot;</span>&gt;&lt;/scrip&gt;<br></code></pre></td></tr></table></figure><blockquote><p>module 的默认加载机制就是 defer，如果和 async 属性一起使用，其加载方式就是 async</p></blockquote><p>除此之外，常常会看到 module script 下方还会跟一个 nomodule script：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip type=<span class="hljs-string">&quot;module&quot;</span> src=<span class="hljs-string">&quot;index.js&quot;</span>&gt;&lt;/scrip&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">scrip</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scrip</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这个功能主要是用来兼容一些老版本的浏览器：</p><p>支持 module 的浏览器，设定上就不会执行 nomodule 属性的 script 脚本，所以它只会跑上方的 js 脚本</p><p>而老版本的浏览器不支持 type&#x3D;”module”，会跳过这个 script 标签；同时又由于它不认识 nomodule 属性，反倒会执行 nomodule script 里的 js 文件</p><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><h3 id="integrity"><a href="#integrity" class="headerlink" title="integrity"></a>integrity</h3><p>该属性允许 script 标签提供一个 hash 值，用于检验加载的 JS 文件是否完整。比如，如下便签的 integrity 值就是告诉浏览器：使用 sha256 算法计算 JS 文件的摘要签名，然后对比 integrity 值，如果不一致就不执行该资源。它的主要功能就是防止托管在 CDN 上的资源被篡改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip<br>  src=<span class="hljs-string">&quot;//code.jquery.com/jquery.js&quot;</span><br>  integrity=<span class="hljs-string">&quot;sha256-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC&quot;</span><br>&gt;&lt;/scrip&gt;<br></code></pre></td></tr></table></figure><h3 id="nonce"><a href="#nonce" class="headerlink" title="nonce"></a>nonce</h3><p>nonce 是一个加密数字，需要配合 Content-Security-Policy 的 script-src 使用。举个例子，http 头的 CSP 属性如下：</p><p><code>Content-Security-Policy: script-src &#39;nonce-EfNBf03nceIOAn39fn389h3sdfa&#39;;</code></p><p>只有在 script 标签内带有相同 nonce 值的脚本才能执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script nonce=<span class="hljs-string">&quot;nonce-EfNBf03nceIOAn39fn389h3sdfa&quot;</span> src=<span class="hljs-string">&quot;./hello.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="referrerPolicy"><a href="#referrerPolicy" class="headerlink" title="referrerPolicy"></a>referrerPolicy</h3><p>该属性主要和 HTTP 头里的 Referer 配合使用。有些服务器审查比较严格，需要知道请求的“引荐人”（Referrer）；客户请求 API 时，需要同时发送引荐人信息。最简单的使用方式就是给相关的 script 标签添加 referrerPolicy 属性：<br><code>&lt;scrip referrerpolicy=&quot;origin&quot; src=&quot;./js/hello.js&quot;&gt;&lt;/scrip&gt;</code><br>如上代码中，hello.js 里的所有 api 请求都会在头信息里加上相应 URL 的域（origin）。referrerPolicy 的值很多，也很琐碎</p><blockquote><p>冷知识：HTTP 头的 Referer 有拼写错误，正确的写法是 Referrer；但是标准提案里写错了，结果大家就将错就错了</p></blockquote><h3 id="crossorigin"><a href="#crossorigin" class="headerlink" title="crossorigin"></a>crossorigin</h3><p>在 HTML5 中，<code>&lt;script&gt;</code> 与其他一些元素（<code>&lt;audio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>、和 <code>&lt;video&gt;</code>）提供了对 CORS 的支持； 他们均有一个跨域属性——crossorigin——来配置元素获取数据的 CORS 请求。一旦启用 crossorigin，http 头里须包含 Access-Control-Allow-Origin 属性，若该属性不存在或是源不必配，则不能加载资源。</p><p>Crossorigin 的默认值是 anonymous（空值或是无效值都等于 anonymous），表示对跨域请求不设置凭据标志；相反，想要提供该凭证，就需要设置 crossorigin&#x3D;”use-credentials”。（这里的凭据，指的就是 cookies、http 里的 auth，以及客户端的 SSL 证书）</p><h3 id="onload-onerror"><a href="#onload-onerror" class="headerlink" title="onload &amp; onerror"></a>onload &amp; onerror</h3><p>onload 和 onerror 算是两个隐藏属性吧，因为只能在<strong>动态引入</strong>时使用。顾名思义，onload 会指向成功加载时的事件，onerror 就是失败时触发的事件。用法也很简单，就是给这两个属性赋值某个事件函数。现实操作中常配合 crossorigin 使用，打印出三方源的一些错误信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.example.com/example.js&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br><br>script.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Success Loading&#x27;</span>)<br>&#125;<br><br>script.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Error Loading&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>扩展小知识：基本上所有包含 src 属性的 HTML 元素都有 onload 和 onerror 这两个隐藏属性，如： <code>&lt;img&gt;</code> 和 <code>&lt;iframe&gt;</code></p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>language: 早年间用来指定脚本语言的属性，如 Javascript、JavaScript1.2、VBScript，不过现在已弃用</p></li><li><p>charset：指定代码的字符集，如 charset&#x3D;”UTF-8”，可惜也已经过时了</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解CORS</title>
    <link href="/2023/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS/"/>
    <url>/2023/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h2><p>Cross-Origin Resource Sharing，跨域资源共享，是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他源，使得浏览器允许这些域加载自己的资源。</p><blockquote><p>跨域是不准确的，CORS 中，包括协议，域名，端口，只要其中之一不同，就是不同的源，因此也称跨源。</p></blockquote><ul><li>服务器：标识哪些源可以访问自己的资源</li><li>HTTP 头：Access-Control-Allow-Origin:* Origin: <a href="https://bilibili.com/">https://bilibili.com</a></li><li>浏览器：必须实现 CORS 相关的规范是否载入都有浏览器控制</li></ul><h2 id="CORS-的工作机制"><a href="#CORS-的工作机制" class="headerlink" title="CORS 的工作机制"></a>CORS 的工作机制</h2><p>script 标签载入了其他域的 JS 脚本，img 标签载入了其他域下的图片，不会作为 CORS 处理。</p><p>最常见适用 CORS 机制的是异步调用 Ajax，XMLHttpReques、Fetch API 等发起的跨域的 HTTP 请求，还有 Web 字体 (CSS 中通过 @font-face 使用跨源字体资源)，WebGL 贴图、使用 drawlmage() 将图片或视频画面绘制到 canvas</p><blockquote><p>简单请求，浏览器直接发起请求，适用于轻量服务，少了预检过程，提升响应速度；非简单请求，浏览器会先发起预检过程，适合于消耗资源的服务，可以减轻服务器压力</p></blockquote><h2 id="为什么需要-CORS"><a href="#为什么需要-CORS" class="headerlink" title="为什么需要 CORS"></a>为什么需要 CORS</h2><ol><li>保护服务器，这有助于减轻服务器的负载和风险</li><li>保护隐私，CORS 限制了敏感数据的访问</li><li>安全考虑，防止盗取用户数据或进行 CSRF 攻击</li><li>因为有实际的跨域请求需求，所以也不能完全禁止跨域请求</li></ol><h2 id="如何解决-CORS-问题"><a href="#如何解决-CORS-问题" class="headerlink" title="如何解决 CORS 问题"></a>如何解决 CORS 问题</h2><ol><li>同源策略（增加反向代理）, Nginx 或者 Apache</li><li>正确设置 CORS 标头，正确响应 Options 预检请求</li><li>JSONP</li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.bilibili.com/video/BV13z4y1F717/?spm_id_from=333.880.my_history.page.click&vd_source=c4a9c068747c74e67180a135f9b6799f">彻底搞懂 CORS（跨域资源共享）相关内容 什么是 CORS 为什么需要 CORS 如何解决 CORS 问题 简单请求 预检</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
      <tag>cors</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器插件之CORS Unblock</title>
    <link href="/2023/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E4%B9%8BCORS-Unblock/"/>
    <url>/2023/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E4%B9%8BCORS-Unblock/</url>
    
    <content type="html"><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul><li>跨域</li></ul><p>跨域全称为 Cross-Origin Resource Sharing，意为跨域资源共享，是一种允许当前域（domain）的资源被其他域（domain）的脚本请求访问的机制，通常由于同源安全策略，浏览器会禁止这种跨域请求。</p><p>而我们所说的跨域问题是因为违反了浏览器的同源安全策略而产生的。</p><ul><li>同源安全策略</li></ul><p>同源安全策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。</p><p>同源是指协议、域名、端口三者相同，即使两个不同的域名指向同一个 ip 地址也是非同源。</p><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</p><h2 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h2><ul><li><p>jsonp：json with padding</p></li><li><p>配置后端：CORS</p></li><li><p>中间服务器代理</p></li><li><p>正向代理<br>正向代理是代理服务器对客户端进行代理，为客户端收发请求，使得真实客户端对目标服务器不可见</p></li><li><p>反向代理<br>反向代理是代理服务器对目标服务器进行代理，为目标服务器进行收发请求，使得真实服务器对客户端不可见，如：Nginx</p></li></ul><p>此前我碰到一个需求，给我一个图片的链接，需要下载图片下来然后用 canvas 在其之上作画，会碰到这个问题:</p><blockquote><p>Uncaught DOMException: Failed to execute ‘toDataURL’ on ‘HTMLCanvasElement’: Tainted canvases may not be exported.</p></blockquote><p>这是受限于 CORS 策略，会存在跨域问题，虽然可以使用图像，但是绘制到画布上会污染画布，一旦一个画布被污染,就无法提取画布的数据，比如无法使用使用画布 toBlob(),toDataURL(),或 getImageData()方法；当使用这些方法的时候 会抛出上面的安全错误</p><p>网上的解决办法是给图片 img 加上一个属性：<code>image.setAttribute(&#39;crossorigin&#39;, &#39;anonymous&#39;);</code><br>并且后端开启 CORS 即可，但是由于受限，无法及时开启后端跨域，因此在高人指点下找到了一款插件 CORS Unblock，这个插件可以很好在自己的浏览器中解决跨域问题</p><p>另外经过查阅知道，火狐浏览器有一个插件叫 CORS Everywhere，谷歌浏览器、Edge 用 <a href="https://webextension.org/listing/access-control.html">CORS Unblock</a> 插件，当然这个插件的功能远不止如此。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>src 和 href 的区别</title>
    <link href="/2023/09/30/src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/30/src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><blockquote><p><code>src</code><strong>主要用于指定要加载的外部资源的路径</strong></p><p><code>href</code><strong>主要用于指定链接的目标资源的 URL</strong></p></blockquote><h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><ul><li>在<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>等标签中使用</li><li>用于指定外部资源的源 URL，浏览器需要获取并嵌入到当前文档中</li><li><code>src</code> 属性用于加载外部资源，如脚本、图片、视频、音频文件等</li></ul><h2 id="href"><a href="#href" class="headerlink" title="href"></a>href</h2><ul><li>在<code>&lt;a&gt;</code>、<code>&lt;link&gt;</code>和<code>&lt;area&gt;</code>等标签中使用</li><li>用于指定超链接的目标 URL，它可以是其他网页、CSS 文件、图片文件等</li><li><code>href</code> 属性用于定义超链接和资源的链接地址</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="请求资源类型不同"><a href="#请求资源类型不同" class="headerlink" title="请求资源类型不同"></a>请求资源类型不同</h3><ul><li><code>href</code>，超文本引用，用于建立文档与资源的联系，适用于：<code>&lt;link&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;base&gt;</code>等标签</li><li><code>src</code>，将其所指向的资源下载并应用到当前页面，适用于：<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>和<code>&lt;audio&gt;</code>等标签</li></ul><h3 id="作用结果不同"><a href="#作用结果不同" class="headerlink" title="作用结果不同"></a>作用结果不同</h3><ul><li><code>href</code>，用于文档与资源之间确立联系</li><li><code>src</code>，请求到的资源替换当前内容</li></ul><h3 id="浏览器解析不同"><a href="#浏览器解析不同" class="headerlink" title="浏览器解析不同"></a>浏览器解析不同</h3><ul><li><code>href</code>，将资源解析成 css 文件，并行加载请求资源，不会阻塞对当前文档的处理</li><li><code>src</code>，会暂停其他资源的处理，直到该资源加载、解析和执行完毕，将其所指向资源应用到当前內容。这也是为什么把 js 文件放在底部而不是放在头部的原因</li></ul><h3 id="语义不同"><a href="#语义不同" class="headerlink" title="语义不同"></a>语义不同</h3><ul><li><code>src</code>属性在页面渲染过程中会阻塞后续内容的加载，因为浏览器会优先加载并执行<code>src</code>对应的资源</li><li><code>href</code>属性不会阻塞后续内容的加载，因此适用于需要异步加载的资源，如样式表和字体文件等</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
