<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vim常用指令</title>
    <link href="/2023/10/30/vim%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/10/30/vim%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="Vim-模式"><a href="#Vim-模式" class="headerlink" title="Vim 模式"></a>Vim 模式</h3><ul><li>正常模式（Normal Mode）：默认模式，可以使用基础命令进行操作</li><li>命令模式（Command Mode）：**冒号 :**起手，可以使用比正常模式更加复杂的命令进行操作</li><li>插入模式（Insert Mode）：主要用于编写文档</li><li>可视模式（Visual Mode）：模拟鼠标选中内容</li></ul><h3 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>a</code></td><td align="center">在光标所在的字符后插入</td></tr><tr><td align="center"><code>A</code></td><td align="center">在光标所在的行尾插入</td></tr><tr><td align="center"><code>i</code></td><td align="center">在光标所在的字符前插入</td></tr><tr><td align="center"><code>I</code></td><td align="center">在光标所在的行首插入</td></tr><tr><td align="center"><code>o</code></td><td align="center">在光标下插入新行</td></tr><tr><td align="center"><code>O</code></td><td align="center">在光标上插入新行</td></tr></tbody></table><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>h j k l</code></td><td align="center">h（左） j（下） k（上） l（右） 移动光标</td></tr><tr><td align="center"></td><td align="center"><strong>在当前行上移动光标</strong></td></tr><tr><td align="center"><code>0</code></td><td align="center">移动到行头</td></tr><tr><td align="center"><code>^</code></td><td align="center">移动到本行的第一个不是 blank 字符</td></tr><tr><td align="center"><code>$</code></td><td align="center">移动到行尾</td></tr><tr><td align="center"><code>g_</code></td><td align="center">移动到本行最后一个不是 blank 字符的位置</td></tr><tr><td align="center"><code>w</code></td><td align="center">光标移动到下一个单词的开头</td></tr><tr><td align="center"><code>e</code></td><td align="center">光标移动到下一个单词的结尾</td></tr><tr><td align="center"><code>fa fb</code></td><td align="center">移动到本行下一个为 a 的字符处，移动到下一个为 b 的字符处</td></tr><tr><td align="center"><code>nfa</code></td><td align="center">移动到本行光标处开始的第 n 个 字符为 a 的地方（n 是 1，2，3，4 … 数字）</td></tr><tr><td align="center"><code>Fa</code></td><td align="center">同 <code>fa</code> 一样，光标移动方向同 <code>fa</code> 相反</td></tr><tr><td align="center"><code>nFa</code></td><td align="center">同 <code>nfa</code> 类似，光标移动方向同 <code>nfa</code>相反</td></tr><tr><td align="center"><code>ta</code></td><td align="center">移动光标至 a 字符的前一个字符</td></tr><tr><td align="center"><code>nta</code></td><td align="center">移动到第 n 个 a 字符的前一个字符处</td></tr><tr><td align="center"><code>Ta</code></td><td align="center">同 <code>ta</code> 移动光标方向相反</td></tr><tr><td align="center"><code>nTa</code></td><td align="center">同 <code>nta</code> 移动光标方向相反</td></tr><tr><td align="center"><code>;</code> 和<code>,</code></td><td align="center">当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用 <code>；</code>可以快速跳转到下一个指定的字符，<code>, </code>是跳到前一个指定的字符</td></tr><tr><td align="center"></td><td align="center"><strong>跨行移动光标</strong></td></tr><tr><td align="center"><code>nG </code></td><td align="center">光标定位到第 n 行的行首</td></tr><tr><td align="center"><code>gg </code></td><td align="center">光标定位到第一行的行首</td></tr><tr><td align="center"><code>G </code></td><td align="center">光标定位到最后一行的行首</td></tr><tr><td align="center"><code>H </code></td><td align="center">光标定位到当前屏幕的第一行行首</td></tr><tr><td align="center"><code>M</code></td><td align="center">光标移动到当前屏幕的中间</td></tr><tr><td align="center"><code>L</code></td><td align="center">光标移动到当前屏幕的尾部</td></tr><tr><td align="center"><code>zt</code></td><td align="center">把当前行移动到当前屏幕的最上方，也就是第一行</td></tr><tr><td align="center"><code>zz</code></td><td align="center">把当前行移动到当前屏幕的中间</td></tr><tr><td align="center"><code>zb</code></td><td align="center">把当前行移动到当前屏幕的尾部</td></tr><tr><td align="center"><code>%</code></td><td align="center">匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上</td></tr><tr><td align="center"><code>*</code> 和 <code>#</code></td><td align="center">匹配光标当前所在的单词，移动光标到下一个（或者上一个）匹配的单词（ <code>*</code> 是下一个，<code>#</code> 是上一个）</td></tr><tr><td align="center"></td><td align="center"><strong>翻页操作</strong></td></tr><tr><td align="center"><code>ctrl+f</code></td><td align="center">查看下一页内容</td></tr><tr><td align="center"><code>ctrl+b</code></td><td align="center">查看上一页内容</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的删除</strong></td></tr><tr><td align="center"><code>dw</code></td><td align="center">删除一个单词</td></tr><tr><td align="center"><code>dnw</code></td><td align="center">删除 n 个单词</td></tr><tr><td align="center"><code>dfa</code></td><td align="center">删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ）</td></tr><tr><td align="center"><code>dnfa</code></td><td align="center">删除光标处到第 n 个 a 的字符处</td></tr><tr><td align="center"><code>dd</code></td><td align="center">删除一整行</td></tr><tr><td align="center"><code>ndd</code></td><td align="center">删除光标处开始的 n 行</td></tr><tr><td align="center"><code>d$</code></td><td align="center">删除光标到本行的结尾</td></tr><tr><td align="center"><code>dH</code></td><td align="center">删除屏幕显示的第一行文本到光标所在的行</td></tr><tr><td align="center"><code>dG</code></td><td align="center">删除光标所在行到文本的结束</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的复制</strong></td></tr><tr><td align="center"><code>y</code></td><td align="center"><code>y</code>是复制的意思</td></tr><tr><td align="center"><code>yw</code></td><td align="center">复制一个单词，还有 <code>ynw</code></td></tr><tr><td align="center"><code>  yfa</code></td><td align="center">复制光标到下一个 a 的字符处,还有<code>ynfa</code></td></tr><tr><td align="center"><code>yy</code></td><td align="center">复制一行，还有 <code>nyy</code></td></tr><tr><td align="center"><code>y$</code></td><td align="center">复制光标到本号的结尾</td></tr><tr><td align="center"><code>yH</code></td><td align="center">复制屏幕显示的第一行文本到光标所在的行</td></tr><tr><td align="center"><code>yG</code></td><td align="center">复制光标所在行到文本的结束</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的黏贴</strong></td></tr><tr><td align="center"><code>p</code></td><td align="center"><code>P</code>是黏贴的意思</td></tr><tr><td align="center"><code>p</code></td><td align="center">在光标后开始黏贴</td></tr><tr><td align="center"><code>P</code></td><td align="center">大写的 P 光标前开始粘贴</td></tr><tr><td align="center"></td><td align="center"><strong>撤销操作和恢复</strong></td></tr><tr><td align="center"><code>u</code></td><td align="center">撤销刚才的操作</td></tr><tr><td align="center"><code>ctrl + r</code></td><td align="center">恢复撤销操作</td></tr><tr><td align="center"></td><td align="center"><strong>删除字符操作和替换</strong></td></tr><tr><td align="center"><code>x</code></td><td align="center">删除光标当前所在的字符</td></tr><tr><td align="center"><code>r</code></td><td align="center">替换掉光标当前所在的字符</td></tr><tr><td align="center"><code>R</code></td><td align="center">替换掉从光标开始以后的所有字符，除非 <code>&lt;ESC &gt;</code> 退出，或者 <code>jj</code> （代替 <code>&lt;ESC&gt;</code>）退出</td></tr><tr><td align="center"></td><td align="center"><strong>大小写转换</strong></td></tr><tr><td align="center"><code>~</code></td><td align="center">将光标下的字母改变大小写</td></tr><tr><td align="center"><code>3~</code></td><td align="center">将光标位置开始的 3 个字母改变其大小写</td></tr><tr><td align="center"><code>g~~</code></td><td align="center">改变当前行字母的大小写</td></tr><tr><td align="center"><code>gUU</code></td><td align="center">将当前行的字母改成大写</td></tr><tr><td align="center"><code>guu</code></td><td align="center">将当前行的字母全改成小写</td></tr><tr><td align="center"><code>3gUU</code></td><td align="center">将从光标开始到下面 3 行字母改成大写</td></tr><tr><td align="center"><code>gUw</code></td><td align="center">将光标下的单词改成大写</td></tr><tr><td align="center"><code>guw</code></td><td align="center">将光标下的单词改成小写</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的重复命令</strong></td></tr><tr><td align="center"><code>.</code></td><td align="center">该命令是重复上一个操作的命令</td></tr><tr><td align="center"><code>n&lt;command&gt;</code></td><td align="center">重复某个命令 n 次</td></tr></tbody></table><h3 id="可视化模式（Visual-mode"><a href="#可视化模式（Visual-mode" class="headerlink" title="可视化模式（Visual-mode)"></a>可视化模式（Visual-mode)</h3><ul><li><code>v</code> 进入 VISUAl 模式</li><li><code>V </code> 进入 VISUAL LINE 模式</li><li><code>Ctrl + v</code> 进入 VISUALBLOCK 模式</li><li>“”，‘’ ，（），{} ，[]（双引号，单引号，小括号，大括号，中括号）,<code>va</code>,<code>vi</code> 会快速选择区域，va 后面会紧跟一个区域结束标志，a 会选中结束符标志，i 就不会</li></ul><h3 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"></td><td align="center"><strong>VIM 的退出</strong></td></tr><tr><td align="center"><code>:w</code></td><td align="center">保存当前对文件的修改，但是不退出文件</td></tr><tr><td align="center"><code>:w!</code></td><td align="center">强制保存但是不退出文件</td></tr><tr><td align="center"><code>:w file</code></td><td align="center">保存当前的文件修改到 file 文件当中</td></tr><tr><td align="center"><code>:q!</code></td><td align="center">退出文件，对文件的修改不做保存</td></tr><tr><td align="center"><code>:qa!</code></td><td align="center">退出所有的文件，对所有的文件修改都不做保存</td></tr><tr><td align="center"><code>:wq</code></td><td align="center">退出文件并保存对文件的修改</td></tr><tr><td align="center"><code>:x</code></td><td align="center">退出文件并保存对文件的修改</td></tr><tr><td align="center"><code>:e file</code></td><td align="center">打开另一个文件</td></tr><tr><td align="center"><code>:e!</code></td><td align="center">放弃对文件的所有修改，恢复文件到上次保存的位置</td></tr><tr><td align="center"><code>:saveas file</code></td><td align="center">另存为 file</td></tr><tr><td align="center"><code>:bn、:bp</code></td><td align="center">当打开多个文件的时候可以输入 <code>:bn</code> 和 <code>:bp</code> 进行上一个文件或者下一个文件的切换</td></tr><tr><td align="center"><code>ZZ</code></td><td align="center">两个大写的 Z (ZZ),这样文件就会快速的保存退出</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 的命令模式</strong></td></tr><tr><td align="center"><code>:set nu</code></td><td align="center">该命令会显示行号</td></tr><tr><td align="center"><code>:set nonu</code></td><td align="center">该命令会取消行号</td></tr><tr><td align="center"><code>:n</code></td><td align="center">定位到 n 行</td></tr><tr><td align="center"><code>:set noic</code></td><td align="center">该命令用来区分大小写的查询</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 进行关键字的查找</strong></td></tr><tr><td align="center"><code>/&#123;目标字符串&#125;</code></td><td align="center">查找文本中匹配的目标字符串，查到以后，输入键盘上的 n 会去寻找下一个匹配，N 会去寻找上一个匹配</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 删除多行文本</strong></td></tr><tr><td align="center"><code>:n1,n2d</code></td><td align="center">n1 和 n2 指的是起始行号和结束行号，d 是删除关键字</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 处理文本的替换</strong></td></tr><tr><td align="center"><code>:&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换的标志&#125;</code></td><td align="center"></td></tr><tr><td align="center"><code>&#123;作用范围&#125;</code></td><td align="center">空则为当前行、%为全文、n1,n2 则为 n1 到 n2 的所有行，选区在可视化模式下</td></tr><tr><td align="center"><code>&#123;替换的标志&#125;</code></td><td align="center"><code>g </code>即是替换标志之一，表示全局 <code>global </code>替换（即替换目标的所有出现）<br />空替换标志表示只替换从光标位置开始，目标的第一次出现<br />i 表示大小写不敏感查找，I 表示大小写敏感<br />c 表示需要确认，例如全局查找”zempty”替换为”handsome”并且需要确认</td></tr><tr><td align="center"></td><td align="center"><strong>VIM 执行 Linux 命令</strong></td></tr><tr><td align="center"><code>:!command</code></td><td align="center"><code>!</code> 后面紧跟着 linux 命令</td></tr><tr><td align="center"><code>:r !command</code></td><td align="center">: 后面紧跟着 r , r 后面是空格，紧接着是 !command，并且添加结果至操作文本光标处</td></tr><tr><td align="center"></td><td align="center"><strong>使用 ab</strong></td></tr><tr><td align="center"><code>:ab email xxxx@gmail.com</code></td><td align="center"><code>:</code> 后面的 ab 是关键字 ,该命令执行后，然后切换到编辑模式下,输入 email 会把输入的 email 自动替换成 <a href="mailto:&#120;&#x78;&#x78;&#x78;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#120;&#x78;&#x78;&#x78;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;</a><br />主要是处理频繁输入同样的长串字符串</td></tr></tbody></table><h3 id="VIM-的代码提示功能"><a href="#VIM-的代码提示功能" class="headerlink" title="VIM 的代码提示功能"></a>VIM 的代码提示功能</h3><p>在编辑模式下 ，快捷键 Ctrl+n 或者 Ctrl+p 会有代码提示功能，可以实现快速录入的效果</p><h3 id="VIM-的宏录制"><a href="#VIM-的宏录制" class="headerlink" title="VIM 的宏录制"></a>VIM 的宏录制</h3>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>script标签</title>
    <link href="/2023/10/26/script%E6%A0%87%E7%AD%BE/"/>
    <url>/2023/10/26/script%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="script-引入"><a href="#script-引入" class="headerlink" title="script 引入"></a>script 引入</h2><p><code>&lt;script&gt;</code> 引入 JS 的方式主要有三种：内联、外置，以及动态引入</p><p>动态引入：动态加载的脚本的情况，这种脚本默认为 async 加载形式，可通过将 async 属性设置为 false 来解除，让脚本顺序执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myScript = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>myScript.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;alert(&quot;hello world&quot;)&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(myScript)<br></code></pre></td></tr></table></figure><blockquote><p>通过 innerHTML 方式其实也能添加 script 标签，只是该标签下的 JS 不会运行，如</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="script-加载"><a href="#script-加载" class="headerlink" title="script 加载"></a>script 加载</h2><p>defer（延迟加载）和 async（异步加载）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 会立即加载并执行指定的脚本，js的下载和执行都会阻塞浏览器对HTML的解析</span><br>&lt;script src=<span class="hljs-string">&quot;index.js&quot;</span>&gt;&lt;/script&gt;<br><span class="hljs-comment">// 后续文档加载和js加载并行进行即异步，js执行会阻塞浏览器对HTML的解析</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="hljs-comment">// 后续文档加载和js加载并行进行即异步，js执行在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/../img/assets/scriptLoading.png" alt="script加载情况" title="script 脚步加载情况"></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a>type 属性</h3><p>type 属性原本是用来指定 script 脚本的 MIME 类型，默认值是 text&#x2F;javascript，其他值还有诸如：text&#x2F;ecmascript、application&#x2F;ecmascript、application&#x2F;javascript 等等，现代浏览器大多不理会这些值，而是把 type 用来支持 es6 的模块功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip type=<span class="hljs-string">&quot;module&quot;</span>&gt;&lt;/scrip&gt;<br></code></pre></td></tr></table></figure><blockquote><p>module 的默认加载机制就是 defer，如果和 async 属性一起使用，其加载方式就是 async</p></blockquote><p>除此之外，常常会看到 module script 下方还会跟一个 nomodule script：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip type=<span class="hljs-string">&quot;module&quot;</span> src=<span class="hljs-string">&quot;index.js&quot;</span>&gt;&lt;/scrip&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">scrip</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scrip</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这个功能主要是用来兼容一些老版本的浏览器：</p><p>支持 module 的浏览器，设定上就不会执行 nomodule 属性的 script 脚本，所以它只会跑上方的 js 脚本</p><p>而老版本的浏览器不支持 type&#x3D;”module”，会跳过这个 script 标签；同时又由于它不认识 nomodule 属性，反倒会执行 nomodule script 里的 js 文件</p><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><h3 id="integrity"><a href="#integrity" class="headerlink" title="integrity"></a>integrity</h3><p>该属性允许 script 标签提供一个 hash 值，用于检验加载的 JS 文件是否完整。比如，如下便签的 integrity 值就是告诉浏览器：使用 sha256 算法计算 JS 文件的摘要签名，然后对比 integrity 值，如果不一致就不执行该资源。它的主要功能就是防止托管在 CDN 上的资源被篡改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;scrip<br>  src=<span class="hljs-string">&quot;//code.jquery.com/jquery.js&quot;</span><br>  integrity=<span class="hljs-string">&quot;sha256-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC&quot;</span><br>&gt;&lt;/scrip&gt;<br></code></pre></td></tr></table></figure><h3 id="nonce"><a href="#nonce" class="headerlink" title="nonce"></a>nonce</h3><p>nonce 是一个加密数字，需要配合 Content-Security-Policy 的 script-src 使用。举个例子，http 头的 CSP 属性如下：</p><p><code>Content-Security-Policy: script-src &#39;nonce-EfNBf03nceIOAn39fn389h3sdfa&#39;;</code></p><p>只有在 script 标签内带有相同 nonce 值的脚本才能执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script nonce=<span class="hljs-string">&quot;nonce-EfNBf03nceIOAn39fn389h3sdfa&quot;</span> src=<span class="hljs-string">&quot;./hello.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="referrerPolicy"><a href="#referrerPolicy" class="headerlink" title="referrerPolicy"></a>referrerPolicy</h3><p>该属性主要和 HTTP 头里的 Referer 配合使用。有些服务器审查比较严格，需要知道请求的“引荐人”（Referrer）；客户请求 API 时，需要同时发送引荐人信息。最简单的使用方式就是给相关的 script 标签添加 referrerPolicy 属性：<br><code>&lt;scrip referrerpolicy=&quot;origin&quot; src=&quot;./js/hello.js&quot;&gt;&lt;/scrip&gt;</code><br>如上代码中，hello.js 里的所有 api 请求都会在头信息里加上相应 URL 的域（origin）。referrerPolicy 的值很多，也很琐碎</p><blockquote><p>冷知识：HTTP 头的 Referer 有拼写错误，正确的写法是 Referrer；但是标准提案里写错了，结果大家就将错就错了</p></blockquote><h3 id="crossorigin"><a href="#crossorigin" class="headerlink" title="crossorigin"></a>crossorigin</h3><p>在 HTML5 中，<code>&lt;script&gt;</code> 与其他一些元素（<code>&lt;audio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>、和 <code>&lt;video&gt;</code>）提供了对 CORS 的支持； 他们均有一个跨域属性——crossorigin——来配置元素获取数据的 CORS 请求。一旦启用 crossorigin，http 头里须包含 Access-Control-Allow-Origin 属性，若该属性不存在或是源不必配，则不能加载资源。</p><p>Crossorigin 的默认值是 anonymous（空值或是无效值都等于 anonymous），表示对跨域请求不设置凭据标志；相反，想要提供该凭证，就需要设置 crossorigin&#x3D;”use-credentials”。（这里的凭据，指的就是 cookies、http 里的 auth，以及客户端的 SSL 证书）</p><h3 id="onload-onerror"><a href="#onload-onerror" class="headerlink" title="onload &amp; onerror"></a>onload &amp; onerror</h3><p>onload 和 onerror 算是两个隐藏属性吧，因为只能在<strong>动态引入</strong>时使用。顾名思义，onload 会指向成功加载时的事件，onerror 就是失败时触发的事件。用法也很简单，就是给这两个属性赋值某个事件函数。现实操作中常配合 crossorigin 使用，打印出三方源的一些错误信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.example.com/example.js&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br><br>script.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Success Loading&#x27;</span>)<br>&#125;<br><br>script.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Error Loading&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>扩展小知识：基本上所有包含 src 属性的 HTML 元素都有 onload 和 onerror 这两个隐藏属性，如： <code>&lt;img&gt;</code> 和 <code>&lt;iframe&gt;</code></p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>language: 早年间用来指定脚本语言的属性，如 Javascript、JavaScript1.2、VBScript，不过现在已弃用</p></li><li><p>charset：指定代码的字符集，如 charset&#x3D;”UTF-8”，可惜也已经过时了</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解CORS</title>
    <link href="/2023/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS/"/>
    <url>/2023/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h2><p>Cross-Origin Resource Sharing，跨域资源共享，是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他源，使得浏览器允许这些域加载自己的资源。</p><blockquote><p>跨域是不准确的，CORS 中，包括协议，域名，端口，只要其中之一不同，就是不同的源，因此也称跨源。</p></blockquote><ul><li>服务器：标识哪些源可以访问自己的资源</li><li>HTTP 头：Access-Control-Allow-Origin:* Origin: <a href="https://bilibili.com/">https://bilibili.com</a></li><li>浏览器：必须实现 CORS 相关的规范是否载入都有浏览器控制</li></ul><h2 id="CORS-的工作机制"><a href="#CORS-的工作机制" class="headerlink" title="CORS 的工作机制"></a>CORS 的工作机制</h2><p>script 标签载入了其他域的 JS 脚本，img 标签载入了其他域下的图片，不会作为 CORS 处理。</p><p>最常见适用 CORS 机制的是异步调用 Ajax，XMLHttpReques、Fetch API 等发起的跨域的 HTTP 请求，还有 Web 字体 (CSS 中通过 @font-face 使用跨源字体资源)，WebGL 贴图、使用 drawlmage() 将图片或视频画面绘制到 canvas</p><blockquote><p>简单请求，浏览器直接发起请求，适用于轻量服务，少了预检过程，提升响应速度；非简单请求，浏览器会先发起预检过程，适合于消耗资源的服务，可以减轻服务器压力</p></blockquote><h2 id="为什么需要-CORS"><a href="#为什么需要-CORS" class="headerlink" title="为什么需要 CORS"></a>为什么需要 CORS</h2><ol><li>保护服务器，这有助于减轻服务器的负载和风险</li><li>保护隐私，CORS 限制了敏感数据的访问</li><li>安全考虑，防止盗取用户数据或进行 CSRF 攻击</li><li>因为有实际的跨域请求需求，所以也不能完全禁止跨域请求</li></ol><h2 id="如何解决-CORS-问题"><a href="#如何解决-CORS-问题" class="headerlink" title="如何解决 CORS 问题"></a>如何解决 CORS 问题</h2><ol><li>同源策略（增加反向代理）, Nginx 或者 Apache</li><li>正确设置 CORS 标头，正确响应 Options 预检请求</li><li>JSONP</li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.bilibili.com/video/BV13z4y1F717/?spm_id_from=333.880.my_history.page.click&vd_source=c4a9c068747c74e67180a135f9b6799f">彻底搞懂 CORS（跨域资源共享）相关内容 什么是 CORS 为什么需要 CORS 如何解决 CORS 问题 简单请求 预检</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
      <tag>CORS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器插件之CORS Unblock</title>
    <link href="/2023/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E4%B9%8BCORS-Unblock/"/>
    <url>/2023/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E4%B9%8BCORS-Unblock/</url>
    
    <content type="html"><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul><li>跨域</li></ul><p>跨域全称为 Cross-Origin Resource Sharing，意为跨域资源共享，是一种允许当前域（domain）的资源被其他域（domain）的脚本请求访问的机制，通常由于同源安全策略，浏览器会禁止这种跨域请求。</p><p>而我们所说的跨域问题是因为违反了浏览器的同源安全策略而产生的。</p><ul><li>同源安全策略</li></ul><p>同源安全策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。</p><p>同源是指协议、域名、端口三者相同，即使两个不同的域名指向同一个 ip 地址也是非同源。</p><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</p><h2 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h2><ul><li><p>jsonp：json with padding</p></li><li><p>配置后端：CORS</p></li><li><p>中间服务器代理</p></li><li><p>正向代理<br>正向代理是代理服务器对客户端进行代理，为客户端收发请求，使得真实客户端对目标服务器不可见</p></li><li><p>反向代理<br>反向代理是代理服务器对目标服务器进行代理，为目标服务器进行收发请求，使得真实服务器对客户端不可见，如：Nginx</p></li></ul><p>此前我碰到一个需求，给我一个图片的链接，需要下载图片下来然后用 canvas 在其之上作画，会碰到这个问题:</p><blockquote><p>Uncaught DOMException: Failed to execute ‘toDataURL’ on ‘HTMLCanvasElement’: Tainted canvases may not be exported.</p></blockquote><p>这是受限于 CORS 策略，会存在跨域问题，虽然可以使用图像，但是绘制到画布上会污染画布，一旦一个画布被污染,就无法提取画布的数据，比如无法使用使用画布 toBlob(),toDataURL(),或 getImageData()方法；当使用这些方法的时候 会抛出上面的安全错误</p><p>网上的解决办法是给图片 img 加上一个属性：<code>image.setAttribute(&#39;crossorigin&#39;, &#39;anonymous&#39;);</code><br>并且后端开启 CORS 即可，但是由于受限，无法及时开启后端跨域，因此在高人指点下找到了一款插件 CORS Unblock，这个插件可以很好在自己的浏览器中解决跨域问题</p><p>另外经过查阅知道，火狐浏览器有一个插件叫 CORS Everywhere，谷歌浏览器、Edge 用 <a href="https://webextension.org/listing/access-control.html">CORS Unblock</a> 插件，当然这个插件的功能远不止如此。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>src 和 href 的区别</title>
    <link href="/2023/09/30/src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/30/src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><blockquote><p><code>src</code><strong>主要用于指定要加载的外部资源的路径</strong></p><p><code>href</code><strong>主要用于指定链接的目标资源的 URL</strong></p></blockquote><h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><ul><li>在<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>等标签中使用</li><li>用于指定外部资源的源 URL，浏览器需要获取并嵌入到当前文档中</li><li><code>src</code> 属性用于加载外部资源，如脚本、图片、视频、音频文件等</li></ul><h2 id="href"><a href="#href" class="headerlink" title="href"></a>href</h2><ul><li>在<code>&lt;a&gt;</code>、<code>&lt;link&gt;</code>和<code>&lt;area&gt;</code>等标签中使用</li><li>用于指定超链接的目标 URL，它可以是其他网页、CSS 文件、图片文件等</li><li><code>href</code> 属性用于定义超链接和资源的链接地址</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="请求资源类型不同"><a href="#请求资源类型不同" class="headerlink" title="请求资源类型不同"></a>请求资源类型不同</h3><ul><li><code>href</code>，超文本引用，用于建立文档与资源的联系，适用于：<code>&lt;link&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;base&gt;</code>等标签</li><li><code>src</code>，将其所指向的资源下载并应用到当前页面，适用于：<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>和<code>&lt;audio&gt;</code>等标签</li></ul><h3 id="作用结果不同"><a href="#作用结果不同" class="headerlink" title="作用结果不同"></a>作用结果不同</h3><ul><li><code>href</code>，用于文档与资源之间确立联系</li><li><code>src</code>，请求到的资源替换当前内容</li></ul><h3 id="浏览器解析不同"><a href="#浏览器解析不同" class="headerlink" title="浏览器解析不同"></a>浏览器解析不同</h3><ul><li><code>href</code>，将资源解析成 css 文件，并行加载请求资源，不会阻塞对当前文档的处理</li><li><code>src</code>，会暂停其他资源的处理，直到该资源加载、解析和执行完毕，将其所指向资源应用到当前內容。这也是为什么把 js 文件放在底部而不是放在头部的原因</li></ul><h3 id="语义不同"><a href="#语义不同" class="headerlink" title="语义不同"></a>语义不同</h3><ul><li><code>src</code>属性在页面渲染过程中会阻塞后续内容的加载，因为浏览器会优先加载并执行<code>src</code>对应的资源</li><li><code>href</code>属性不会阻塞后续内容的加载，因此适用于需要异步加载的资源，如样式表和字体文件等</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
